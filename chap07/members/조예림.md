## 개요

분산 시스템에서는 `AUTO_INCREMENT` 방식만으로는 **전역 유일한 ID 생성**이 어렵습니다.

이 문서에서는 대표적인 ID 생성 전략 4가지를 비교하고, **Twitter Snowflake 방식**을 중심으로

**64비트 숫자형 ID를 안정적으로 생성하는 구조와 운영 전략**을 설명합니다.

---

**읽고 나면 알 수 있는 것**

- 기존 방식의 한계와 분산 환경에서의 과제
- 대표적인 ID 생성 방식 4가지의 장단점
- Snowflake 방식의 ID 구조, 동작 원리, 운영 시 고려사항

---

## 1. 문제 정의

### 1.1 기존 방식의 한계: `AUTO_INCREMENT`

`AUTO_INCREMENT` 방식은 단일 DB에서 순차적으로 ID를 생성하는 구조로,

다음과 같은 이유로 분산 시스템에 적합하지 않습니다.

| 문제 | 설명 |
| --- | --- |
| **단일 서버 의존** | ID 생성이 특정 DB에 집중되어 병목과 단일 장애 지점(SPOF)이 발생합니다. |
| **수평 확장 불가** | 중복 방지를 위해 DB를 수평 확장하기 어렵고, 이는 확장성과 탄력성을 제한합니다. |
| **동기화 비용 증가** | 여러 DB에서 중복 없는 ID를 생성하려면 상태 공유 및 조율이 필요해 지연이 커집니다. |

---

## 1.2 요구사항 도출 과정

시스템 설계 문제를 해결할 때는 먼저 **요구사항을 명확히 파악**하고,

모호한 부분은 **질문을 통해 해소**해야 합니다.

아래는 면접 상황에서 오갈 수 있는 질의 예시입니다.

### 면접 질문 예시

- **ID는 어떤 특성을 가져야 하나요?**
    
    → 유일해야 하고, 정렬 가능해야 한다.
    
- **ID는 항상 1씩 증가하나요?**
    
    → 꼭 1씩 증가할 필요는 없지만, 시간이 흐를수록 값이 커져야 한다.
    
- **ID는 숫자로만 구성되나요?**
    
    → 그렇다.
    
- **초당 생성량은 어느 정도인가요?**
    
    → 초당 10,000개 ID 생성이 가능해야 한다.
    

---

## 1.3 최종 요구사항 정리

위 질문을 바탕으로, 시스템이 만족해야 할 ID 생성 요건은 다음과 같습니다.

- **ID는 전역적으로 유일해야 한다.**
- **숫자 형태로 구성되어야 한다.**
- **64비트 정수 내에서 표현 가능해야 한다.**
    
    → 유일성, 정렬성, 성능, 시스템 간 호환성을 종합적으로 충족
    
- **시간 흐름에 따라 정렬 가능해야 한다.**
- **초당 최소 10,000개 이상의 ID를 생성할 수 있어야 한다.**

---

## 2. 후보 방식 검토

다양한 방식의 ID 생성 전략을 검토하고, 각각의 **장단점과 제약 조건을 비교**하여 설계 방향에 대해 면접관과 **공감대를 형성**하는 것이 이 단계의 목표입니다.

---

### 2.1 다중 마스터 복제

![image.png](https://github.com/user-attachments/assets/e288d936-949a-436b-bbfe-4f567c3b4c0d)

**설명**

여러 DB 서버(MySQL 등)가 각자 `AUTO_INCREMENT` 방식으로 ID를 생성하되,

**서버별로 증가 간격과 시작 값을 다르게 설정**해 ID 충돌을 방지하는 방식입니다.

예를 들어, `auto_increment_increment = 서버 수`, `auto_increment_offset = 서버 번호`와 같이 구성합니다.

이 방식을 통해 각 서버는 고유한 ID를 병렬로 생성할 수 있습니다.

---

**장점**

- **ID 충돌 없이 병렬 생성 가능**
    
    각 서버가 고유한 설정으로 ID를 생성하므로 조율 없이도 충돌 없는 병렬 처리가 가능합니다.
    
- **수평 확장 가능**
    
    서버 수만큼 ID 생성이 분산되어 전체 처리량을 일정 수준까지 확장할 수 있습니다.
    

---

**단점**

1. **시간 순 정렬 불가**
    
    ID가 생성 순서와 무관하게 증가하므로, 시간 기반 정렬이나 범위 쿼리에 부적합합니다.
    
2. **운영 복잡도 증가**
    
    서버를 추가하거나 제거할 경우, 모든 노드의 설정을 재조정해야 하며 기존 ID와의 충돌 가능성도 존재합니다.
    
3. **글로벌 확장에 제약**
    
    다중 데이터센터 환경에서는 설정 동기화가 까다롭고, 네트워크 지연이나 장애 시 안정성 확보가 어렵습니다.
    

---

### 2.2 UUID

![image.png](https://github.com/user-attachments/assets/40b9585c-4219-495c-a5af-232952e2f6d9)

**설명**

UUID(Universally Unique Identifier)는 **128비트 크기의 고유 ID**를 생성하는 방식입니다.

서버 간 조율이나 상태 공유 없이도 **전역적으로 유일한 ID를 자체 생성**할 수 있어,

분산 환경에서 널리 사용되는 간단한 접근법입니다.

예시: `09c93e62-50b4-468d-bf8a-c07e1040bfb2`

---

**장점**

- **구현이 단순하고 독립적**
    
    서버 간 통신이나 동기화 없이, 각 서버가 자체적으로 ID를 생성할 수 있습니다.
    
- **충돌 가능성 매우 낮음**
    
    초당 10억 개를 100년간 생성해도 중복될 확률이 50%에 불과할 정도로 안전합니다.
    
- **수평 확장에 유리함**
    
    각 서버가 독립적으로 동작하므로, 노드 수와 관계없이 확장이 자유롭습니다.
    

---

**단점**

1. **ID 크기가 큼 (128비트)**
    
    저장 공간과 네트워크 전송 비용이 증가하며, 이 장의 요구사항인 **64비트 범위를 초과**합니다.
    
2. **정렬 불가능**
    
    UUID는 랜덤하게 생성되므로, **시간 기반 정렬이나 범위 쿼리**에는 부적합합니다.
    
3. **숫자 기반 ID가 아님**
    
    UUID는 알파벳을 포함하므로, 숫자만으로 구성된 ID를 요구하는 시스템에서는 제약이 있습니다.
    

---

> **💬 내 생각**
UUID에서도 다양한 버전이 있고, 타임스탬프 기반이라 시간 정렬 가능한 것도 있었다.
또, 충돌 확률 낮추기 위해 128비트로 설계한 것 같은데 상황에 따라 64비트도 나쁘지 않을 것 같다.
예전에 프로젝트에서 주문 번호 생성할 때 UUID 쓴 적 있었는데, 그때는 주문일자(YYYYMMDD)+UUID 일부 압축해서 붙여 썼던 걸로 기억난다. (이미 존재하면 재생성)
이번 장을 읽고 다시 구현하라고 한다면, Snowflake 방식처럼 구조화된 ID 설계도 고려할 것 같다. 정렬도 되고, 인덱스 성능도 좋을 테니까..
다만, MSA 환경에서는 주문 전용 인스턴스를 둘지, 여러 인스턴스가 동시에 ID를 생성할지 등 구조를 고려해야 할 듯 하다.
> 

---

### 2.3 티켓 서버

![image.png](https://github.com/user-attachments/assets/2d383752-796e-406d-a5f0-77c6eca99818)

**설명**

하나의 중앙 서버(DB 또는 API)를 **ID 발급 전용 티켓 서버**로 두고,

각 서비스 노드가 **필요할 때마다 이 서버에 ID를 요청**받아 사용하는 방식입니다.

보통 내부적으로는 DB의 `AUTO_INCREMENT` 기능을 활용하며,

ID는 **숫자 기반의 순차적 값**으로 제공됩니다.

---

**장점**

- **숫자 기반 ID 제공**
    
    `AUTO_INCREMENT` 기반이라 숫자로 구성된 ID를 순차적으로 발급할 수 있습니다.
    
- **유일성 보장**
    
    중앙 서버가 일관된 규칙으로 ID를 발급하므로 충돌 우려가 없습니다.
    
- **구현이 단순하고 직관적**
    
    복잡한 분산 처리가 필요 없으며, **중소규모 시스템에 빠르게 적용** 가능합니다.
    

---

**단점**

1. **단일 장애 지점 (SPOF)**
    
    티켓 서버에 장애가 발생하면 **전체 시스템에서 ID 생성이 중단**됩니다.
    
    신뢰성과 가용성 확보가 어려운 구조입니다.
    
2. **확장성 제한**
    
    트래픽이 늘어날수록 티켓 서버가 **병목 지점**이 됩니다.
    
    대량 요청 처리에는 부적합합니다.
    
3. **운영 복잡성 증가 (다중 인스턴스 구성 시)**
    
    티켓 서버를 여러 대로 구성하려면 **분산 락 또는 동기화**가 필요하며,
    
    이로 인해 **구현 난이도와 복잡성이 증가**합니다.
    

---

> 💬 내 생각
> 
> 
> Flickr에서는 이 방식으로 MySQL의 `AUTO_INCREMENT`를 중앙 티켓 서버로 감쌌고,
> 
> **SPOF 문제를 완화하기 위해 짝수/홀수로 ID 공간을 나눠 두 개의 서버를 운영**했다고 한다.
> 

---

### 2.4 트위터 Snowflake

**설명**

Twitter에서 개발한 Snowflake는 **64비트 숫자형 ID를 필드 단위로 분할**해 구성하는 방식으로,

**전역 유일성, 시간 정렬성, 수평 확장성**을 모두 만족시킬 수 있는 ID 생성 전략입니다.

ID는 시간, 데이터센터, 서버, 시퀀스 번호를 조합하여 구성되며, **분산 환경에서도 충돌 없이 독립 생성**이 가능합니다.

---

**ID 구조 (총 64비트)**

![image.png](https://github.com/user-attachments/assets/5cad7de7-ee9d-4818-a3c9-ffbec28fa18a)

| 필드 | 비트 수 | 설명 |
| --- | --- | --- |
| **Sign 비트** | 1 | 항상 0으로 고정 (미사용 필드) |
| **타임스탬프** | 41 | 기준 시점(epoch) 이후의 경과 시간 (밀리초 단위) |
| **데이터센터 ID** | 5 | 최대 32개 데이터센터 구분 가능 |
| **서버 ID** | 5 | 데이터센터당 최대 32대 서버 식별 |
| **시퀀스 번호** | 12 | 같은 밀리초 내 최대 4,096개 ID 생성 가능 |

> 전체적으로 약 69년 동안 사용할 수 있으며, 밀리초 단위로 정렬 가능한 숫자 ID를 제공합니다.
> 

---

> 💬 내 생각
트위터를 포함해 대부분의 서비스 수명은 20~30년 안팎이라고 한다.
그럼에도 69년이 지나면 상위 비트를 1로 변환해서 69년 재연장하는 식으로 한다면 될 듯하다.
> 

---

**장점**

- **64비트 내에서 유일성과 정렬성 확보**
    
    시간, 위치 정보, 시퀀스를 조합해 **중복 없이 정렬 가능한 ID 생성**이 가능합니다.
    
- **서버 간 통신 없이도 충돌 없음**
    
    각 서버가 독립적으로 동작하며, 사전 설정만으로 유일성 보장됩니다.
    
- **수평 확장에 유리함**
    
    데이터센터와 서버 ID 필드를 통해 구조적으로 확장이 용이하며,
    
    **수천만 건 이상**의 초당 생성량도 대응 가능합니다.
    
- **숫자 기반 정렬 ID**
    
    저장, 검색, 인덱싱에 유리하며, 범위 쿼리도 효율적으로 수행됩니다.
    

---

**단점 / 주의할 점**

1. **시계 역행(Clock Skew) 이슈**
    
    서버 시간이 뒤로 가는 경우 **중복 ID가 생성될 수 있어 위험**합니다.
    
    일부 구현에서는 시계 재동기화 또는 밀리초 단위 대기(wait) 전략으로 대응합니다.
    
2. **고정된 구조로 인한 유연성 부족**
    
    각 필드의 비트 수가 고정되어 있어, **요구사항 변화에 따라 구조 재설계가 필요**할 수 있습니다.
    
    예: 데이터센터가 32개를 넘는 경우, 필드 비트 분배를 조정해야 함
    

---

## 3. 최종 설계: Snowflake 기반 ID 생성기

이 단계에서는 앞서 정의한 필드 구조를 바탕으로, **ID를 어떻게 실제로 운영하고 관리할 것인지**

를 구체화합니다. 각 필드의 설정 시점과 동작 방식, 그리고 운영상의 주의사항을 정리합니다.

---

### 3.1 동작 원리

각 필드는 설정 시점과 역할에 따라 두 그룹으로 나눌 수 있습니다.

### 고정 값 (서버 기동 시 설정)

- **데이터센터 ID / 서버 ID**
    
    시스템 **기동 시 설정**되며, **운영 중에는 변경하지 않습니다.**
    
    → 변경 시 동일 서버에서 생성된 ID가 충돌할 수 있으므로 **매우 신중하게 관리**해야 합니다.
    

### 동적 값 (ID 생성 시 계산)

- **타임스탬프**
- **시퀀스 번호**

---

### 3.2 운영 전략

### 타임스탬프

![image.png](https://github.com/user-attachments/assets/72e18c1d-2d22-489f-a4f8-20e7576adb0c)

Snowflake ID에서 **가장 큰 비중(41비트)**을 차지하는 핵심 필드로,

**기준 시각(epoch)** 이후 경과된 **밀리초 단위의 시간**을 나타냅니다.

---

**운영 원칙**

- **Epoch은 전 서버에서 고정**
    
    → 기준 시각은 UTC 기준으로 설정하며, 모든 서버에서 **동일하게 유지**해야 합니다.
    
    → 운영 중 변경하지 않으며, 이를 통해 **정합성과 충돌 방지**가 가능합니다.
    
- **시간 순 정렬 가능**
    
    → 시간이 흐를수록 타임스탬프 값이 증가하므로, 생성된 ID도 **자연스럽게 정렬**됩니다.
    

---

**변환 가능성**

- ID에서 타임스탬프 추출 → **UTC 시간으로 변환 가능**
- UTC 시간 → **밀리초 단위 타임스탬프로 변환 가능**

→ 디버깅, 로그 추적, 장애 분석 등에서 **추적성과 가시성**을 높여줍니다.

---

**수명 및 범위**

- 41비트로 표현 가능한 최대 시간: `2^41 - 1 ≈ 2조 1990억 밀리초`
- 약 **69년간 사용 가능**
    
    (`= 2,199,023,255,551ms ÷ 1000 ÷ 60 ÷ 60 ÷ 24 ÷ 365 ≈ 69년`)
    

> 따라서 epoch은 한 번만 설정하면,
> 
> 
> 운영 중 변경이나 재조정 없이도 **안정적인 장기 운영이 가능**합니다.
> 

---

### 시퀀스 번호

시퀀스 번호는 같은 밀리초 안에 생성되는 ID들의 **중복을 방지하는 카운터 역할**을 합니다.

12비트로 구성되어 있어, **한 서버당 같은 밀리초 내에 최대 4096개(2¹²)**의 ID를 생성할 수 있습니다.

---

**운영 방식**

- 기본적으로 **0부터 시작**하며, **같은 밀리초 내에 여러 개의 ID가 요청될 때**만 증가합니다.
- **4096개를 초과하는 요청이 발생하면**, ID 생성기는 **다음 밀리초까지 대기(wait)**해야 합니다.

---

## 4. 운영 고려사항 및 확장 전략

### 4.1 시계 동기화

Snowflake 방식은 **모든 서버가 동일한 시간을 기준으로 동작**한다는 전제 하에 설계됩니다. → 시간 정

하지만 실제 환경에서는 **서버 간 시계 오차(Clock Skew)**가 발생할 수 있으며,

이로 인해 **ID 충돌 또는 정렬 오류**가 생길 수 있습니다.

---

**대응 방법**

- **NTP(Network Time Protocol)** 사용
    
    대부분의 시스템은 NTP를 통해 서버 시계를 주기적으로 동기화합니다.
    
- **시계 역행(rollback) 감지 및 대응**
    
    일부 구현체에서는 타임스탬프가 과거로 되돌아가는 경우
    
    - **ID 생성을 잠시 대기(wait)**하거나,
    - **오류를 반환하고 재시도**하게 처리합니다.

---

### 4.2 필드 비트 재설계 가능성

**재설계가 필요한 상황**

| 시스템 특성 | 재설계 방향 | 이유 |
| --- | --- | --- |
| **동시성이 낮고, 장기 운영** | 시퀀스 ↓ / 타임스탬프 ↑ | 초당 ID 생성량이 적으므로 시퀀스 비트를 줄이고, 더 오랜 기간 사용할 수 있도록 타임스탬프 수명 확보 |
| **동시성이 매우 높고, 단기 중심 운영** | 시퀀스 ↑ / 타임스탬프 ↓ | 타임스탬프 수명이 짧아도 괜찮고, 밀리초당 생성량이 많아 시퀀스 비트를 넉넉히 확보해야 함 |

---

### 4.3 고가용성

ID 생성기는 장애 시 **전체 시스템에 영향을 주는 핵심 컴포넌트**입니다.

따라서 **중단 없는 운영을 위한 고가용성 설계**가 필수입니다.

---

**운영 전략**

- **다중 인스턴스 구성**
    
    단일 장애 지점을 피하기 위해 **여러 노드로 구성**,
    
    필요 시 **failover 또는 로드 밸런싱** 적용
    
- **서버 ID 충돌 방지**
    
    각 인스턴스의 **서버 ID는 중복 없이 고정 설정**해야 하며,
    
    이를 위한 **배포 자동화 또는 구성 관리 도구** 사용 권장
    
- **설정은 기동 시 고정**
    
    `서버 ID`, `데이터센터 ID`는 **기동 이후 변경 금지**
    
    → 변경 시 **ID 충돌 위험**
    

---

> 📌 Zookeeper, Etcd, 환경 변수 매핑 등을 통해
> 
> 
> 서버 ID 할당을 **자동화하거나 고정적으로 관리**하는 것이 일반적입니다.
> 

---

## 📎 부록

### 참고 자료

- [UUID - Wikipedia](https://en.wikipedia.org/wiki/Universally_unique_identifier)
- [Flickr 티켓 서버 아키텍처](https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)
- [Twitter Snowflake 소개](https://blog.x.com/engineering/en_us/a/2010/announcing-snowflake)
- [Network Time Protocol (NTP)](https://en.wikipedia.org/wiki/Network_Time_Protocol)
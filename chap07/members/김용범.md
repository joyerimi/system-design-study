# 7장 - 분산 시스템을 위한 유일 ID 생성기 설계

## 들어가며

단일 서버 시스템을 구현하면서 항상 ID 생성 메커니즘을   `@Id @GeneratedValue(strategy = GenerationType.IDENTITY)`를 통해 자동으로
1씩 증가하도록 생성해왔다. 하지만 분산 시스템에서는 데이터베이스가 여러 개가 되면서 그냥 1씩 증가하는 방식은 사용할 수 없다고 생각한다. 이 장에서는 분산 시스템에서 유일한
ID를 생성하는 방법을 소개하고 있다.

책에서는 앞선 3장 `시스템 설계 면접 공략법`에서 살펴본 4단계 단계를 활용하여 설명을 하고 있다. 따라가보자!

## 1단계: 문제 이해 및 설계 범위 확정

다음과 같은 문제 상황을 가정해보자.

1. ID는 유일해야 한다.
2. ID는 숫자로만 구성되어야 한다.
3. ID는 64비트로 표현될 수 있는 값이어야 한다.
4. ID는 발급 날짜에 따라 정렬 가능해야 한다.
5. 초당 10,000개의 ID를 만들 수 있어야 한다.

## 2단계: 개략적 설계안 제시 및 동의 구하기

분산 시스템에서 유일한 ID를 보장하는 방법은 여러 가지가 있다. 그 중 4가지 정도를 살펴보자.

1. 다중 마스터 복제
2. UUID
3. 티켓 서버
4. Snowflake

### 다중 마스터 복제

`다중 마스터 복제 방법`은 데이터 베이스의 `auto_increment` 기능을 활용하되, ID 값을 1씩 증가시키는 것이 아니라 데이터베이스 서버의 수 k만큼 증가시킨다. 즉,
현재 데이터베이스 서버의 수가 3개라면 특정 데이터베이스 서버의 현재 생성된 ID 값이 1이라고 한다면 1 -> 4 -> 7... 과 같이 증가하는 방식이다. 이렇게 구현하게
된다면, k개의 데이터베이스 서버끼리 충돌되는 상황은 발생하지 않을 것이다.

![Image](https://github.com/user-attachments/assets/03d36983-aa21-4294-b814-49a410ad5e96)

이렇게만 본다면 k개에 맞춰서 ID를 생성하면 별 문제가 없어보이지만 치명적인 단점이 있다. 데이터베이스 서버가 추가되거나 삭제될 때, k값이 바뀌어 버리게 되면서 기존의 ID 값
또한 변경해줘야 한다는 것이다. 규모를 늘리기 어려워 지고, 늘리더라도 그 규모에 맞게 ID가 커지도록 보장할 수 없다.

- 장점
    - 데이터베이스 서버의 개수가 k개로 고정된 상황이라면, ID 유일성을 확보하면서 충돌까지 방지할 수 있다.
- 단점
    - 분산 시스템에서 데이터베이스 서버의 개수는 상황에 맞춰서 늘어나거나 줄어들 수 있다. 이때마다 k값의 변화에 따라 ID 값이 변경되어야 한다는 점에서 확장성에 한계가
      있다.
    - 즉, 분산 시스템 환경에서 제대로 동작하도록 만들기가 어렵다.

### UUID

`UUID`는 유일성이 보장되는 ID 생성 방법 중 하나로, 128비트의 숫자 및 문자로 구성된 ID이다. UUID는 충돌 가능성이 지극히 낮고, 중복 UUID가 1개 생길 확률을
50%로 끌아 올리려면 초당 10억 개의 UUID를 100년 동안 계속해서 만들어야 한다고 한다. UUID 값은 다음과 같은 형식을 띤다.

```text 
d2fccab4-4e7a-4c75-a71b-be6d2b347d0e
```

![Image](https://github.com/user-attachments/assets/65023506-406c-4c4a-8dae-7f0e106fa068)

UUID는 라이브러리를 활용하여 쉽게 생성해낼 수 있고, 각 웹서버마다 UUID를 생성해낼 수 있는 구조이기 때문에 분산 시스템에서 유일한 ID를 보장한다. 하지만, 문자를
포함한다는 점과 128비트라는 긴 길이를 가진다는 단점이 있다. 또한, 시간 순으로 정렬할 수 없어 ID를 기준으로 정렬시킬 수 없다.

- 장점
    - 분산 시스템에서 각 서버가 독립적으로 유일한 ID를 생성할 수 있다.
    - 생성이 간단하다.
- 단점
    - 128비트라는 긴 길이를 가진다.
    - 문자를 포함하고 있고, ID를 시간 순으로 정렬할 수 없다.

### 티켓 서버

### Snowflake

## 3단계: 상세 설계

## 4단계: 마무리
# 가상 면접 사례로 배우는 대규모 시스템 설계 기초(8장)

스터디 날짜: 2025년 7월 30일

# URL 단축기 설계

- URL 단축기가 왜 필요할까?
    - URL이 길면 기분이 안 좋음
    - 문자수 제한이 있을 때 유용함
    - 리다이렉션 기반이라 사용자 통계가 가능함

## 요구사항

- 단축 URL에 접속하면 원래의 URL로 가야 한다.
- 매일 1억 개의 단축 URL을 만들어야 한다.
    - 매초 = 1억 / 24 / 3600 = 1160 개의 URL을 만들어야 한다.
    - 읽기 연산과 쓰기 연산이 10:1 비율이라면, 읽기 연산은 매초 11,600회 발생한다.
    - 10년간 URL 단축 서비스를 운영한다면, 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 한다.
        - 축약 전 URL의 평균 길이는 100이라고 할 때, 저장 공간은 36.5TB가 필요하다.
- 단축 URL의 길이는 짧으면 짧을 수록 좋다.
- 단축 URL에는 숫자, 알파벳 소문자, 대문자만 사용할 수 있다.
    - NanoID?
- 단축 URL은 삭제나 갱신을 할 수 없다.

## API 설계하기

단축 URL을 삭제하거나 갱신할 필요는 없다고 했다.

- 그렇다면 단축 URL을 **생성하는 것과 조회**하는 API만 설계하면 된다.

### 단축 URL 생성 API

- 요청: 기존의 URL
- 응답: 단축된 URL

### 단축 URL 조회 API

- 응답: 기존의 URL로 리다이렉트

## URL 리디렉션

단축 URL을 입력 받으면 원래의 URL을 location header에 담아 301 응답을 날린다.

이때 302로도 날릴 수 있는데 둘의 차이점을 유의해서 알아야 한다.

<img width="1297" height="1392" alt="image" src="https://github.com/user-attachments/assets/618b473c-4e0f-4768-ac58-d7a500b2a771" />


### 301 Permanently Moved

- 현재 입력받은 URL(shorten url)의 책임이 영구적으로 원래의 URL로 넘어갔다는 의미이다.
- 항상 같은 location으로 요청이 리디렉션 될 것이기 때문에 브라우저는 이 응답을 캐시한다.
- 추후에 같은 url로 요청을 보내게 될 때, 단축 서버에 요청을 보내지 않고 브라우저 단에서 처리하여 원래 URL로 요청을 보내게 된다.

### 302 Found

- 현재 입력받은 URL이 일시적으로만 location이 가리키는 URL로 위임됐다는 뜻이다.
- 언제 다시 책임이 돌아올지 모르기 때문에 브라우저는 이 요청을 캐시하지 않는다. 즉, 항상 서버에 들려서 응답을 받아와야 한다.

### 각각의 장점

- 301 같은 경우에는 브라우저 단에서 캐시하여 처리하기 때문에 서버로의 부하가 오지 않는다.
- 302 같은 경우에는 항상 서버로 요청이 가기는 하지만, 해당 URL에 대한 트래픽 분석이 중요할 때에는 유리하다.

### 구현

가장 직관적으로 구현하는 방법은 hash table을 사용하는 것이다.

- (shorten URL, original URL)의 쌍으로 저장하게 된다면, 키값인 단축 URL을 통해서 원래 URL을 가져올 수 있다.

## URL 단축

- 입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야 한다.
    - 해시 충돌이 나면 안된다.
    - 또는 해시 충돌 해소 로직을 구현해야 한다.
- 계산된 해시 값은 원래 입력으로 주어진 URL로 복원될 수 있어야 한다.
    - 양방향 암호화

## 데이터 모델

앞에서 해시 테이블에 유지하는 것이 가장 직관적이라고 했는데, 사실 이는 그리 좋은 방법이 아닐 수 있다.

- 해시 테이블은 메모리에 유지하게 되는데, 앞서 말했던 것처럼 10년동안 서비스를 유지하게 된다면 36TB의 크기의 메모리가 필요하게 된다. 말도 안 된다.

차라리 더 저렴한 방법으로 RDB에 저장할 수 있다. disk는 memory보다 훨씬 싸다.

## 해시 함수

해시의 값은 [0-9, a-z, A-Z]의 문자들로 구성된다. 즉, 62개의 문자를 한 칸에 쓸 수 있다.

n개의 칸에 62개의 문자가 들어갈 수 있다고 한다면 62^n이 된다. 이 값이 3650억보다 작으면 된다.

- n이 7일 때 3.5조가 된다. 7자리면 모든 단축 url을 표현할 수 있다.

### 해시 후 충돌 해소

<img width="1895" height="1181" alt="image 1" src="https://github.com/user-attachments/assets/1725b530-d7b1-4df2-8df6-423f55dcf222" />


DB를 확인해서 해시 값이 존재하면 다시 해시 생성을 하는 로직을 수행한다.

- 여기에서는 원본 URL에 특정 문자를 추가하며 해시 과정을 반복한다.
    - 여기에서 이상한 점. 텍스트로는 해시값에 문자열을 붙인다고 써있는데, 그림에는 longURL에 붙인다고 써있음. longURL에 붙이는 게 맞을 거 같긴 함.
- 그런데 해시를 할 때마다 DB에서 조회하게 된다면 오버헤드가 크다. 이를 해결하기 위해 블룸 필터를 사용할 수 있다.
    - 확률론에 기초하기 때문에 공간 효율이 좋다.

### base-62  변환

hash 값은 62개의 문자로 이루어지기 때문에 base-62로 변환한다.

<img width="1817" height="800" alt="image 2" src="https://github.com/user-attachments/assets/dde7895e-eb20-40eb-a84d-d9948c3372d2" />


- base-62를 사용하게 된다면 `유일ID 생성 -> hash(유일ID) -> 원본URL과 매핑`의 단계를 거치는 건가?

<img width="1401" height="1259" alt="image 3" src="https://github.com/user-attachments/assets/9a11177b-3f2e-4420-8649-dfc754b1fa32" />


- 새로운 ID를 생성할 때 어떤 유일ID 생성기를 사용해야 할까?
    - 시간 순서대로 증가하지 않아도 된다.
    - 길이에 제한이 있어야 한다.
- 굳이 유일 ID를 생성한 뒤에 hash를 거치는 것보다 그냥 바로 nanoId를 쓰면 되지 않나?

## URL 리디렉션 상세 설계

<img width="1833" height="846" alt="image 4" src="https://github.com/user-attachments/assets/332f9da6-0f7c-44e2-8d76-1dfb2d7c5aa9" />


앞서 일기와 쓰기의 비율이 10:1 이라고 했다. 읽기 작업이 훨씬 많기 때문에 단축url와 원본url의 쌍을 캐시하여 성능을 높일 수 있다.

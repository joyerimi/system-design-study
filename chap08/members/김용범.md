# 들어가며

이번 8장은 `URL 단축키 설계` 내용을 다룬다. 종종 URL 단축하는 서비스를 사용해본 적은 있지만, 그게 어떻게 동작하는지는 생각해본 적은 없었다. 이번 장을 토대로 긴
길이를 가지는 URL 주소를 어떻게 짧게 단축하고, 본래의 URL 주소로 연결하는지 알아보려고 한다. 그럼 시스템 설계 면접 4단계 접근법으로 접근해보자.

## 1단계: 문제 이해 및 설계 범위 확정

우선, `URL 단축키 설계` 문제를 해결하기 위해서 추상적인 설계 작업을 면접관 또는 기술자와 구체화하는 작업이 필요하다. 다음과 같은 요구사항을 정리해보자.

1. URL 단축 -> 짧으면 짧을수록 좋다.
2. URL 리디렉션 -> 축약된 URL로 HTTP 요청이 들어오면 원래 URL로 안내한다.
3. 높은 가용성과 규모 확장성, 그리고 장애 감내가 요구된다.
4. 트래픽 규모는 `매일 1억`개의 단축 URL을 만들어 낼 수 있어야 한다.
5. URL 주소에는 `숫자`, `영문자(대, 소문자 모두 포함)`만 사용할 수 있다.
6. 단축된 URL을 시스템에서 삭제하거나 갱신할 수 없다.

위 내용을 바탕으로 개략적 추정을 하면 다음과 같은 결과가 나온다.

1. 쓰기 연산: `매일 1억` 개의 단축 URL 생성
2. 초당 쓰기 연산: 1억 / (24 * 60 * 60) = 약 `1,160개`
3. 읽기 연산: 읽기 연산과 쓰기 연산을 `10:1 비율`로 가정하면 초당 1160 * 10 = 약 `11,600개`
4. 이 서비스를 10년 간 운영한다고 가정하면 1억 * 365일 * 10년 = `3,650억 개`의 단축 URL 생성
5. 단축 전 URL의 평균 길이는 100자라고 가정하면, 3,650억 * 100Byte = 약 `36.5TB` 저장 용량 필요

## 2단계: 개략적 설계안 제시 및 동의 구하기

문제를 이해했고, 추상적인 설계 범위를 면접관과 대화를 통해 구체화했다면 이제는 개략적인 설계안을 제시해보자. URL 단축키 설계에서 중요한 부분은 `API EndPoint`,
`URL Redirection`, `URL 단축 Flow` 3가지이다.

### API EndPoint

우리는 REST 환경에서 해당 서비스를 설계한다고 가정해본다면, URL 단축키는 2개의 `REST API EndPoint`가 필요하다.

1. POST /api/v1/data/shorten
    - 기존의 긴 URL을 받아서 짧은 URL로 변환하는 API 이다. 즉, URL 단축용 API 이다.
2. GET /api/v1/shortUrl
    - 짧은 URL을 받아서 원래의 긴 URL로 리디렉션하는 API 이다. 즉, URL 리디렉션용 API 이다.

### URL Redirection

![Image](https://github.com/user-attachments/assets/30965259-b442-4fa4-be6a-e7ef337cc66d)

전반적인 URL Redirection 구조는 위 이미지와 같다. 우리 즉, 클라이언트에서 단축된 URL을 주소창에 입력하여 요청하면 URL 단축키 서비스 서버에서 301 또는
302 Redirection 기능을 활용해서 기존의 원본 URL로 연결해주는 역할을 해주는 것이다.

그러면 여기서 301 상태 코드와 302 상태 코드에 대한 차이점을 알아보자.

#### 301 상태 코드 (= Permanently Moved)

301 상태 코드는 HTTP 요청의 처리 책임이 `영구적으로` Location 헤더에 반환된 URL로 이전되었음을 의미한다. 즉, 영구적으로 URL이 변경된 상태기 때문에
브라우저는 이 응답을 캐시에 저장시켜둔다. 이후에 같은 요청이 들어오면 브라우저의 캐시를 통해서 원래 URL로 요청을 보내게 된다.

<img width="705" height="444" alt="Image" src="https://github.com/user-attachments/assets/76e81fee-4a84-4bed-a67d-5758c7fdf76e" />

위 사진은 현재 직접 운영중인 `retrip.kr` 홈페이지에 대한 curl 명령어를 보낸 결과이다. `curl -vi https://retrip.kr` 명령어를 통해서 헤더
정보만 가져오면, HTTP 80 URL에서 `HTTP/1.1 301 Moved Permanently` 상태 코드와 함께 Location 헤더에 HTTPS URL인
`https://retrip.kr` URL이 반환되는 것을 확인할 수 있다. 이러한 설정은 nginx를 통해서 할 수 있다. 이 전체적인 플로우는 아래 그림과 같다.

<img width="3840" height="2987" alt="Image" src="https://github.com/user-attachments/assets/f26f2301-95bf-4223-88e1-0d8953a76a0d" />

#### 302 상태 코드 (= Found)

302 상태 코드는 `일시적으로` Location 헤더가 지정하는 URL로 요청을 보내야 함을 의미한다. 즉, 일시적이기 때문에 브라우저는 이 요청을 캐시에 저장하지 않고, 언제나
URL 단축 서버를 거쳐서 원래 URL로 리디렉션되어야 한다.

#### 301(= Permanently) vs 302(= Temporary)

요청이 너무 많아 서버의 부하를 줄이기 위해서는 브라우저의 캐시를 활용하는 301 상태 코드를 활용하는 것이 유리하다. 그러나, 클릭 발생률이나 발생 위치 등 트래픽 분석을 하기
위해서는 302 상태 코드를 사용하는 것이 더 유리하다.

### URL 단축 Flow

![Image](https://github.com/user-attachments/assets/b93a26e1-2f95-473d-8adc-f493b2ab376c)

URL 단축은 기본적으로 긴 URL을 받아서 짧은 URL로 변환하는 작업이다. 이때, 어떻게 긴 URL을 짧은 URL로 변환시킬 것인지 그 방법이 관건이다. 가장 먼저 떠오르는
것은 해시 값을 사용하는 것이다. 긴 URL에 짧은 URL과 연결지어서 짧은 URL이 입력되면 해시 테이블에서 원본 URL을 찾아서 리디렉션하는 것이다.

## 3단계: 상세 설계

이제 개략적인 설계안을 토대로 상세 설계를 어떻게 해야할 지 생각해보자. 생각해 볼 것은 다음 3가지이다.

1. 데이터 모델
2. 해시 함수
3. URL 단축 및 리디렉션에 관한 구체적인 설계

### 데이터 모델

![Image](https://github.com/user-attachments/assets/456bbc3b-bd54-4083-bd04-0a2f5abe8b56)

데이터 모델은 말 그대로 데이터베이스 테이블에 해시값으로 변환한 짧은 URL과 원본 URL을 함께 저장하는 것이다. 이 전략은 정말 데이터가 별로 없는 초기 전략으로는 괜찮지만,
데이터가 쌓이면 쌓일수록 비용은 계속 늘어날 것이다.

### 해시 함수

![Image](https://github.com/user-attachments/assets/595b907d-d942-4a0f-8fb0-a4f4fe58e83b)

해시 함수는 긴 URL을 짧은 URL로 변환하는 데 쓰인다. 긴 URL을 해시 함수에 넣어서 반환된 결괏값을 `hashValue`라고 하자. 1단계에서 개략적으로 설계한 URL
범위는 `3,650억` 개이다. URL로 사용할 수 있는 문자에는 0-9, a-z, A-Z가 있다. 즉, 62개의 문자를 사용할 수 있는 것이다. 각 자리마다 62개의 경우의 수가
생기며, 문자의 길이가 6개일 때, 대략 568억 개의 URL을 생성할 수 있고, 문자의 길이가 7개일 때, 약 3.5조개의 URL을 생성할 수 있다. 따라서 설계한 URL 범위를
만족하기 위해서는 단축 URL의 길이는 7로 설정해야 한다.

해시 함수를 구현하는 방법에는 크게 2가지 방법이 존재한다.

1. 해시 후 충돌 해소 방법
2. base62 변환법

#### 해시 후 충돌 해소 방법

![Image](https://github.com/user-attachments/assets/cb2d04e9-42ff-4166-9e9d-82e357d82e91)

위에서 말한 것처럼 원본 URL의 길이를 해시 함수를 통해서 최소 7글자 정도로 변환해야 한다는 것을 알았다. 그렇지만, 현재 상용으로 쓰이는 해시 함수 `CRC32`,
`MD5`, `SHA-1` 모두 7글자보다 길다. 그나마 `CRC32` 해시 함수가 8글자로 가장 짧다.

그러면 어떻게 하면 좋을까? 가장 간단한 해결법은 그냥 상용으로 쓰이는 해시 함수를 활용해서 해시 값을 구한 후, 앞 7글자만 잘라서 사용하는 것이다. 하지만 이렇게 계속
사용하다보면 해시 충돌 확률이 높아지는 위험이 있다. 이럴 경우 책에서는 해시 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙이면 된다고 나와있는데, 설명이 모호한 부분이
있는 것 같다. 설명 이미지에는 longURL 뒤에 사전에 정한 문자열을 추가하여 다시 해시 함수를 구하는 플로우로 나와있다.

![Image](https://github.com/user-attachments/assets/9aeef075-4ba2-4abe-a46d-e636682856c5)

뭐가 맞는 방법인지는 모르겠지만, longURL 뒤에 사전에 정한 문자열을 추가하여 다시 해시 함수(longURL + 특정 문자열)를 다시 구하여 원본 URL과 해당 (
longURL + 특정 문자열)에 대한 해시 값을 매핑하는 방식이 옳다고 생각한다. 왜냐하면 원본 URL은 훼손되면 안되기 때문이다. 이 방법은 해시 충돌이 발생할 때마다 DB를
검사해야 하므로 오버헤드가 크다. 따라서 어떤 집합에 특정 원소가 있는지 검사할 수 있는 `블룸 필터` 기술을 활용하면 성능을 더욱 높일 수 있다.

<img width="1386" height="578" alt="Image" src="https://github.com/user-attachments/assets/5b2a9d58-94a2-4184-8ea2-39677f4c803e" />

위 사진은 실제 URL 단축 서비스로 운영 중인 `Buly`라는 플랫폼이다. 여기서는 어떤 방식을 사용할까 궁금하여 검색해봤다. `naver.com`을 단축 URL로 만들면,
`7FPIvdo`라는 7글자의 해시 값이 동일하게 나오는 것을 확인했다. 이 책을 읽고 만들었을까? 싶을 정도로 책의 설명이 그대로 구현되어 있는 느낌이 들었다. 그러면 해당 단축
URL에 대해서 curl 명령어를 한번 날려보자.

`curl -vi https://buly.kr/7FPlvdo` 명령어를 실행하면 가장 먼저 확인할 수 있는 것은 바로 301 상태 코드이다. 즉, 영구적으로 리디렉션 되었다는
것으로, 이 주소는 브라우저 캐시에 저장될 것이다.

<img width="366" height="90" alt="Image" src="https://github.com/user-attachments/assets/a2a28075-3aa9-4eb6-aa31-804645a2a90f" />

이후에 Location 헤더를 확인해보면, `https://www.naver.com`으로 리디렉션 되는 것을 확인할 수 있다. 즉, 원본 URL로 리디렉션이 잘 되는 것을 확인할
수 있다.

<img width="481" height="70" alt="Image" src="https://github.com/user-attachments/assets/69e9d272-c64e-4831-8ab8-840537d29c5e" />

실제로 이렇게 curl 명령어로 직접 확인해보니 이 서비스가 어떤 방식으로 동작하는지 이해가 잘 되었다.

#### base62 변환법

![Image](https://github.com/user-attachments/assets/856d9ad2-1b69-40f6-b1fc-8219cde2ec2a)

base62 변환법은 말 그대로 사용할 수 있는 62개의 문자를 활용해서 62진법을 만들어 내는 것이다. 0은 0으로, 9는 9로, 10은 a로, 35는 z로, 36은 A로,
61은 Z로 변환하는 것이다. `11157` 이란 숫자를 62진법으로 표현하면 `2TX`가 된다. 즉, 단축 URL은 `https://tinyurl.com/2TX` 가 되는
것이다.

#### 해시 훔 충돌 해소 방법 vs base62 변환법

![Image](https://github.com/user-attachments/assets/1cc4fe08-d9d5-4a34-8e2d-75b7bc3a3e74)

두 접근법의 차이를 요약하면 위 이미지와 같다. 분산 환경이라면 auto_increment 기능을 활용할 수 없기 때문에 Snowflake와 같은 ID 생성기를 활용한 base62
변환법을 사용하는 것이 더 유리하지 않을까? 생각이 든다. 그 이유는 해시 충돌이 일어날 일이 없고, 그로 인해 DB 검사를 해야하는 작업도 수행하지 않아도 되기 때문이다.

### URL 단축 및 리디렉션에 관한 구체적인 설계

URL 단축기는 핵심 컴포넌트이기 때문에 가용성을 중요시 여겨야 한다. 즉, 언제나 동작하는 상태로 유지되어야 한다. base62진법 변환 기법을 사용한 전체적인 플로우는 다음과
같다.

![Image](https://github.com/user-attachments/assets/c49209d5-14c8-4e81-bbe2-2643c60189c2)

여기서 단축키의 주된 용도는 단축 URL을 만들 때 사용할 ID를 만드는 것이다. 그렇기 때문에 분산 환경에서 전역적 유일성이 보장되어야 한다. 또한, URL 단축 서비스는 쓰기
연산보다는 읽기 연산이 더 많이 쓰일 것이라고 판단된다. 따라서 캐시를 사용하면 읽기 성능을 보다 높일 수 있을 것이다.

![Image](https://github.com/user-attachments/assets/4272bde1-d5b2-4d92-9fbc-fb63cbd71dce)

## 4단계: 마무리

지금까지 URL 단축키 설계에 대해서 알아보았다. 이외에도 생각하면 좋은 것들이 있다.

1. 처리율 제한 장치
    - 엄청난 양의 URL 단축 요청이 밀려들 경우 무력화될 수 있다는 잠재적 보안 결함을 갖고 있다. 이럴 경우 처리율 제한 장치를 사용하여 요청을 제한할 수 있다.
2. 웹 서버의 규모 확장
    - 본 설계에서는 무상태 계층이므로, 웹 서버를 자유로이 증설하거나 삭제할 수 있다.
3. 데이터베이스의 규모 확장
    - 데이터베이스를 다중화하거나 샤딩하여 규모 확장성을 달성할 수 있다.
4. 데이터 분석 솔루션
    - 데이터 분석 솔루션을 통합해 두면 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 얻을 수 있다.
5. 가용성, 데이터 일관성, 안정성
    - 대규모 시스템이 성공적으로 운영되기 위해서는 반드시 갖추어야 할 속성들이다.
이번 장은 긴 URL을 짧은 URL로 변환하는 시스템을 설계하는 과정을 단계별로 설명합니다. 대규모 트래픽과 확장성을 고려한 설계 전략을 함께 다룹니다.

## 1단계. 문제 이해 및 설계 범위 확정

### 1-1. 문제 정의

- 긴 URL을 입력받아 짧은 URL을 생성하는 시스템을 설계합니다.
- 생성된 단축 URL로 접속하면 원래 URL로 리디렉션되도록 합니다.

예시

```
입력:  https://www.systeminterview.com/q=chatsystem...
출력: https://tinyurl.com/ly7ke-ocwj
```

### 1-2. 주요 요구사항 정리 (Q&A 형식)

- **Q. 트래픽 규모는?**
    
    → 하루 약 **1억 개**의 단축 URL이 생성됩니다.
    
- **Q. 단축 URL 길이는?**
    
    → **짧을수록 좋으며**, 동시에 **유일성**이 보장되어야 합니다.
    
- **Q. 사용 가능한 문자는?**
    
    → **숫자(0~9)**, **소문자(a~z)**, **대문자(A~Z)**로 구성된 **62가지 문자**만 사용 가능합니다.
    
- **Q. 단축 URL의 삭제나 갱신은 가능한가요?**
    
    → 설계를 단순화하기 위해, **삭제 및 갱신은 불가능**하다고 가정합니다.
    

### 1-3. 시스템 기능 요약

1. **URL 단축**
    - 긴 URL을 입력받아 짧고 고유한 단축 URL을 생성합니다.
2. **리디렉션**
    - 단축 URL로 접속 시, 대응되는 원래 URL로 리디렉션합니다.
3. **비기능 요구사항**
    - **고가용성**: 서비스가 항상 접근 가능해야 함
    - **확장성**: 대규모 트래픽 증가에 유연하게 대응 가능해야 함
    - **장애 감내성**: 일부 장애가 발생해도 시스템 전체가 영향을 받지 않도록 설계

### 1-4. 수치 기반 추정

서비스 규모를 가늠하기 위해, 단축 URL 생성량, 읽기/쓰기 비율, 저장 용량 등을 아래와 같이 추정합니다.

| 항목 | 수치 |
| --- | --- |
| **일일 단축 URL 생성량** | 약 1억 건 (100 million) |
| **초당 쓰기 연산량** | 약 1,160 (1억 ÷ 24시간 ÷ 3600초) |
| **초당 읽기 연산량** | 약 11,600 (쓰기의 10배 가정) |
| **10년 누적 데이터** | 약 3,650억 건 |
| **평균 원본 URL 길이** | 100 bytes |
| **총 저장 용량 (10년)** | 약 36.5TB (3,650억 × 100 bytes) |

> 읽기 연산은 쓰기보다 10배 많다고 가정하였으며, 이는 실제 서비스 환경에서 사용자의 리디렉션 요청이 더 빈번하게 발생한다는 점을 반영한 수치입니다.
> 

---

## 2단계. 개략적 설계안 제시 및 동의 구하기

### 2-1. API 설계

| 기능 | 메서드 | 엔드포인트 | 설명 |
| --- | --- | --- | --- |
| 단축 URL 생성 | `POST` | `/api/v1/data/shorten` | 긴 URL을 입력받아 단축 URL을 생성합니다. |
| 리디렉션 처리 | `GET` | `/api/v1/{shortUrl}` | 단축 URL 요청 시 원래 URL로 리디렉션합니다. |

### 2-2. 리디렉션 처리 방식

![image.png](https://github.com/user-attachments/assets/6747c309-2c74-461f-9699-b88b38970672)

### A. 리디렉션 정책 (HTTP 응답 코드 비교)

단축 URL 요청에 대해 클라이언트에게 어떤 HTTP 응답 코드를 반환할지에 따라 시스템의 성능 및 분석 가능성에 영향을 줍니다.

### 301 (Moved Permanently)

- **특징**: 영구 이동
- **장점**: 브라우저가 결과를 캐시하여 **반복 요청 시 서버 부하 감소**
- **단점**: 리디렉션 로그가 클라이언트 측에서 처리되어 **분석 데이터 수집이 어려움**

### 302 (Found)

- **특징**: 임시 이동
- **장점**: 매 요청이 서버에 도달하므로 **클릭 수, 위치 등 트래픽 분석 가능**
- **단점**: 매번 서버까지 요청이 전달되어 **부하 증가**

> **분석**이 중요한 서비스: 302
> 
> 
> **성능이 중요한 서비스**: 301
> 

서비스 목적에 따라 적절한 리디렉션 코드를 선택해야 합니다.

### B. 리디렉션 처리 로직

단축 URL 요청을 처리할 때, 서버는 내부적으로 해시 테이블(Map 구조)을 활용하여 원래 URL을 조회하고 리디렉션을 수행합니다.

### 기본 동작 방식

- **단축 URL을 키**, **원래 URL을 값**으로 저장하는 **해시 테이블**을 사용합니다.
- 요청이 들어오면, 해당 키를 조회하여 원래 URL로 리디렉션합니다.

```python
original_url = hash_table.get(short_url)
return redirect(original_url, status=301 or 302)
```

### 처리 순서

1. 클라이언트 요청에서 `short_url` 추출
2. 해시 테이블에서 `short_url`에 대응하는 `original_url` 조회
3. 조회 결과를 사용하여 `301` 또는 `302` 상태 코드로 리디렉션 응답 반환

### 2-3. URL 단축 처리 방식 개요

![image.png](https://github.com/user-attachments/assets/701c66a5-e486-4ae2-8777-92b83cbec7df)

URL 단축은 결국 긴 URL을 짧은 고유값으로 변환하는 과정이며, 이를 위해 사용하는 해시 함수에는 다음과 같은 조건이 필요합니다.

- **동일한 URL은 항상 동일한 단축 URL**로 매핑되어야 함 → **중복 방지**
- 해시 결과는 **충돌이 없어야 함** → **고유성 보장**
- 해시값만으로는 원래 URL을 복원할 수 없기 때문에, **매핑 정보를 저장**해두어야 함

> 해시 기반 방식은 구현이 간단하지만, 충돌 처리와 저장 전략이 함께 설계되어야 합니다.
> 

---

## 3단계. 상세 설계

### 3-1. 데이터 모델 설계

![image.png](https://github.com/user-attachments/assets/d1be29b0-2917-49fa-815a-7098c5032538)

단축 URL과 원본 URL 간의 매핑 정보를 저장하기 위해, 관계형 데이터베이스(RDBMS)를 사용합니다. 각 URL은 고유한 ID를 기준으로 저장됩니다.

### 테이블 구조

| 컬럼 | 설명 |
| --- | --- |
| `id` | 고유 ID (Primary Key) |
| `shortURL` | 단축된 URL (Base62 인코딩 값) |
| `longURL` | 원래의 긴 URL |

> 메모리 기반 저장 방식은 용량과 지속성의 한계가 있기 때문에, 실제 운영 환경에서는 관계형 데이터베이스를 사용하여 안정적으로 URL 매핑 정보를 관리합니다.
> 

### 3-2. URL 단축 방식 비교

### A. 해시 함수 기반 방식

긴 URL을 **해시 함수**로 변환하여 짧은 문자열(`shortURL`)을 얻는 방식입니다.

### 1) 문자셋과 길이 계산

- 사용 가능한 문자는 **숫자(0-9)·소문자(a-z)·대문자(A-Z)**, 총 **62개**입니다.
- 10년 동안 약 **3,650억 개**의 단축 URL이 필요하므로,
    
    `62⁷ ≈ 3.5조`로 **7자리**면 충분합니다.
    

### 2) 충돌 해결 절차

![image.png](https://github.com/user-attachments/assets/e98ad332-e282-4838-abeb-064b79e3c352)

1. URL에 **CRC32·MD5·SHA-1** 등 해시 함수 적용
    
    ![image.png](https://github.com/user-attachments/assets/72288e35-868b-4d89-bfd1-c4740ae94c6d)
    
2. **앞 7자**만 잘라 단축 URL로 사용
3. **이미 사용 중이면**(충돌) 특정 문자열을 덧붙여 다시 해시 → DB 확인을 반복

> 단점: 충돌이 날 때마다 DB를 여러 번 조회해야 하므로 성능이 저하됩니다.
> 

### 3) Bloom Filter로 최적화

- **비트 배열 + 여러 해시 함수**를 이용해 “존재 여부”를 빠르게 판별
- 생성 직전 Bloom Filter를 먼저 조회
    - 하나라도 `0`이면 “절대 없음” → **DB 조회 생략**
    - 모두 `1`이면 “있을 수도 있음” → 그때만 DB 조회

이 방식은 단순하면서도 짧은 키를 보장하지만, 충돌 관리와 Bloom Filter 튜닝이 필요합니다.

### B. Base62 변환 방식

고유 ID(예: **Auto-Increment** 또는 **분산 ID**)를 **62진법(Base62)** 문자열로 변환해 단축 URL 키로 사용하는 방법입니다.

1. **ID 생성**
    - 데이터베이스 시퀀스나 Snowflake 같은 분산 ID 알고리즘으로 **고유 정수 ID**를 발급합니다.
2. **Base62 인코딩**
    - 발급된 ID를 **숫자(0-9), 소문자(a-z), 대문자(A-Z)** 62개 문자로 변환합니다.
    - 예시: `ID = 11157` → `Base62 = XT2`
        
        ![image.png](https://github.com/user-attachments/assets/27243082-7db3-4233-b8c3-1cad50295a7f)
        
3. **단축 URL 구성**
    - 변환된 문자열이 곧 단축 URL의 키가 됩니다.
    - 예: `https://tinyurl.com/XT2`

### 장점

- **충돌이 없음**: ID 자체가 고유하므로 중복 걱정이 없습니다.
- **구현이 단순**: 해시 충돌 처리나 Bloom Filter가 필요 없습니다.

### 단점

- **보안 취약**: ID가 순차 증가하면 다음 단축 URL을 예측할 수 있어 추측 공격에 노출될 수 있습니다.

### C. 두 방식 비교 표

| 항목 | 해시 후 충돌 해결 | Base62 변환 |
| --- | --- | --- |
| 키 길이 | **고정** (예: 7자리) | **가변** — ID가 커질수록 길어짐 |
| 충돌 가능성 | **있음** → 별도 충돌 처리 필요 | **없음** |
| 유일성 보장 | 해시 충돌 탐지·해소 로직 필요 | 고유 ID로 자연스럽게 보장 |
| 다음 shortURL 예측 | **불가** (랜덤성) | **가능** → 보안상 취약 |

### 3-3. URL 단축 처리 플로우 (단계별)

![image.png](https://github.com/user-attachments/assets/e2de6f07-3761-4209-b596-ffdfa16324c7)

1. **URL 입력**
    
    사용자가 단축하려는 긴 URL을 제출합니다.
    
    ```
    입력: https://en.wikipedia.org/wiki/Systems_design
    ```
    
2. **DB 확인**
    
    먼저 데이터베이스를 조회하여 동일한 URL이 이미 단축되어 있는지 확인합니다.
    
    - **존재**하면: 기존 `shortURL`을 그대로 반환합니다.
    - **없으면**: 새 단축 URL을 생성하는 과정으로 이동합니다.
3. **ID 생성**
    
    전역 고유 ID(예: Snowflake·시퀀스 등)를 하나 발급합니다.
    
    ```
    생성된 ID: 2009215674938
    ```
    
4. **Base62 변환**
    
    발급된 정수 ID를 62진법(Base62) 문자열로 인코딩합니다.
    
    ```
    Base62 변환 결과: zngedcu
    ```
    
5. **DB 저장**
    
    매핑 정보를 테이블에 기록합니다.
    
    | ID | shortURL | longURL |
    | --- | --- | --- |
    | 2009215674938 | zngedcu | https://en.wikipedia.org/wiki/Systems_design |
6. **응답 반환**
    
    최종적으로 사용자에게 단축 URL을 전달합니다.
    
    ```
    출력: https://tinyurl.com/zngedcu
    ```
    

> 이 과정을 통해 시스템은 중복 생성을 방지하고, 고유성이 보장된 짧은 URL을 빠르게 제공합니다.
> 

### 3-4. 리디렉션 처리 상세 설계

### 동작 흐름

![image.png](https://github.com/user-attachments/assets/558c1a00-f611-42f8-9242-c08ba6eeaa98)

1. 사용자가 단축 URL에 접속합니다.
2. **로드밸런서**가 요청을 적절한 웹 서버로 전달합니다.
3. 웹 서버는 우선 **캐시**에서 `shortURL`을 조회합니다.
    - **캐시 히트**: 곧바로 원래 URL을 가져와 리디렉션 응답을 보냅니다.
    - **캐시 미스**: 다음 단계로 넘어갑니다.
4. **DB**에서 `shortURL`에 대응되는 `longURL`을 조회합니다.
    - DB에도 없다면 잘못된 URL 요청으로 판단해 404를 반환할 수 있습니다.
5. DB에서 찾은 `longURL`을 **캐시에 저장**한 뒤 사용자에게 리디렉션 응답을 보냅니다.

> 리디렉션 처리는 읽기 성능이 핵심입니다. 캐시를 적극 활용해 DB 부하를 줄여야 합니다.
> 

### 3-5. 고유 ID 생성 전략: Snowflake

서버가 여러 대로 분산되어 있으므로, 각 서버가 충돌 없이 고유 ID를 자체 발급해야 합니다. 이를 위해 Snowflake를 사용합니다.

**동작**

1. **긴 URL 입력**
    
    사용자가 단축하고 싶은 긴 URL을 서버에 제출합니다.
    
2. **Snowflake ID 생성**
    
    서버는 Snowflake 알고리즘으로 **전역 유일한 64비트 정수 ID**를 만듭니다.
    
    - 구성: `타임스탬프 + 데이터센터ID + 머신ID + 시퀀스번호`
3. **Base62 변환**
    
    생성된 숫자 ID를 **Base62 문자열로 변환**해 짧고 유일한 `shortURL`을 만듭니다.
    
4. **DB 저장**
    
    `(ID, shortURL, longURL)` 형태로 데이터베이스에 저장합니다.
    
5. **shortURL 응답**
    
    최종 단축 URL을 사용자에게 반환합니다.
    
    예: `https://tinyurl.com/zngedcu`
    

---

## 4단계. 마무리 및 확장 고려

단축 URL 시스템을 안정적으로 운영하기 위해 고려할 만한 확장 포인트들을 정리합니다.

### 4-1. 트래픽 보호: 처리율 제한기

사용자나 IP가 과도하게 요청을 보내는 경우를 막기 위해 **속도 제한(Rate Limiting)**이 필요합니다.

필요 시 **토큰 버킷**이나 **IP 기반 제한** 등을 적용할 수 있습니다.

### 4-2. 웹 서버 확장성

웹 서버는 **Stateless**하게 구성되어 있어, 수평 확장(스케일 아웃)이 자유롭습니다.

서버 수를 늘리는 것만으로도 처리량을 쉽게 높일 수 있습니다.

### 4-3. 데이터베이스 확장성

URL 수가 계속 늘어나면 단일 DB로는 한계가 옵니다.

**샤딩**이나 **복제(Replication)**를 통해 스토리지를 분산하면 확장성과 안정성을 확보할 수 있습니다.

### 4-4. 분석 기능

클릭 수, 시간대, 지역 등 사용자 행동 데이터를 수집하면 **마케팅이나 운영 인사이트**에 활용할 수 있습니다.

로그를 저장하고 대시보드에 시각화하면 분석 기능으로 확장할 수 있습니다.

### 4-5. 시스템 속성 복습

서비스가 커질수록 **고가용성**, **일관성**, **안정성**이 중요해집니다.

- **가용성**: 일부 장애가 발생해도 서비스는 계속 동작해야 함
- **일관성**: 데이터 불일치가 최소화되어야 함
- **안정성**: 예측 가능한 방식으로 동작해야 함
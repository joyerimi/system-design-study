# URL 단축키 설계

### 들어가기 전 : URI vs URL vs URN
[참고자료 URI와 URL, 무슨 차이가 있나?](https://www.elancer.co.kr/blog/detail/74)

<img width="1124" height="439" alt="Image" src="https://github.com/user-attachments/assets/b81a8e32-a244-4c50-9f7c-5b876fafea5b" />

## 1단계 : 문제 이해 및 설계 범위 확정
여느 때와 다름없이 가상 면접을 통한 요구사항 파악이 있었습니다.
- URL을 단축할 수 있다 : 주어진 긴 URL을 훨씬 짧게 줄인다.
- URL 리디렉션 : 축약된 URL로 HTTP 요청이 오면 원래 URL로 보내야 한다.
- 높은 가용성과 규모 확장성, 그리고 장애 감내가 요구된다.
- 쓰기 연산은 매일 1억 개 -> 초당 쓰기 연산은 1160개
- 읽기 연산은 쓰기 연산과의 비율을 10:1이라고 가정
- 10년간 서비스를 운영한다면 3650억개의 레코드 보관 필요
- 축약 전 URL의 평균 길이는 100
- 10년 동안 필요한 저장용량은 3650억 * 100바이트 = 36.5TB

## 2단계 : 개략적 설계안 제시 및 동의 구하기

### API 엔드포인트
클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신합니다. 이 엔드포인트는 REST API 스타일로 설계할 예정입니다.
URL 단축키는 기본적으로 2개의 엔드포인트를 필요로 합니다.
1. URL 단축용 엔드포인트 : 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보내야 한다.
    이 엔드포인트는 다음과 같은 형태를 띱니다.  
   - POST /api/v1/data/shorten
     - 인자 : {longUrl : longURLstring}
     - 반환 : 단축 URL
2. URL 리디렉션용 엔드포인트 : 단축 URL에 대해서 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트.
    - GET /api/vi/shortUrl
      - 반환 : HTTP 리디렉션 목적지가 될 원래 URL

### URL 리디렉션
<img width="660" height="333" alt="Image" src="https://github.com/user-attachments/assets/a8c5b055-65a6-4676-888f-6a8207e1f860" />

그림은 브라우저에 단축 URL을 입력 시 생기는 일을 나타냅니다.
단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어서 301 응답의 Location 헤더에 넣어 반환합니다.

<img width="465" height="477" alt="Image" src="https://github.com/user-attachments/assets/8866ed52-8442-4fcf-b71e-fe4b379a9572" />

301과 302 응답은 리디렉션 관련 응답이지만 차이가 있습니다.
- 301 Permanently Moved : 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답입니다.
  영구적으로 이전되었으므로 브라우저는 이 응답을 캐시 처리합니다. 추후 같은 단축 URL에 요청을 보낼 필요가 있을 때 브라우저는 캐시된 원래
  URL로 요청을 보내게 됩니다.
- 302 Found : 주어진 URL로의 요청이 '일시적으로' Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답입니다.
  따라서 클라이언트의 요청은 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 되어야 합니다.

서버 부하를 줄이는 것이 목적이라면 301을 사용하는 것이 좋습니다. 첫번 째 요청만 단축 URL 서버로 보내지기 때문입니다.
트래픽 분석이 목적이라면 302를 쓰는 쪽이 클릭 발생률이나 발생 위치를 추적하는 데 좀 더 유리합니다.

URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것입니다.
해시 테이블에 <단축 URL, 원래 URL> 쌍을 저장한다고 가정하면 다음과 같이 구현 가능합니다.
- 원래 URL = hashTable.get(단축 URL)
- 301 또는 302 응답 location 헤더에 원래 URL을 넣은 후 전송

### URL 단축
단축 URL이 www.tinyurl.com/{hashValue} 같은 형태라고 한다면, 결국 중요한 것은 긴 URL을 이 해시 값으로 대응시킬 해시함수를 찾는 일입니다.
해시함수는 다음의 요구사항을 만족해야 합니다.
- 입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야 한다.
- 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.

## 3단계 : 상세 설계
이번 절에서는 데이터 모델, 해시 함수, URL 단축 및 리디렉션에 관한 구체적인 설계안을 살펴보겠습니다.

### 데이터 모델
이전 절에서는 데이터를 해시 테이블에 저장하였는데, 실제 시스템에서는 메모리의 유한함과 비용으로 인해 사용하기 어렵습니다.
보다 나은 방법은 <단축 URL, 원래 URL> 쌍을 RDB에 저장하는 것입니다. PK로 id, shortURL, longURL을 컬럼으로 가지는 테이블을 설계하여 저장합니다.

### 해시 함수
해시 함수는 원래 URL을 단축 URL로 변환하는 데 사용합니다. 편의상 해시 함수가 계산하는 단축 URL 값을 hashValue라고 지칭하겠습니다.

#### 해시 값 길이
hashValue는 [0-9a-zA-Z]의 문자들로 구성됩니다. 따라서 사용가능한 문자의 개수는 10 + 26 + 26 = 62개입니다.
hashValue의 길이를 정하기 위해서는 62^n >= 3650억인 n의 최솟값을 찾아야 합니다.

<img width="360" height="337" alt="Image" src="https://github.com/user-attachments/assets/c3f7729b-df73-423f-be20-f5227fd910f6" />

n = 7이라면 3.5조 개의 URL을 만들 수 있으므로 요구사항이 만족됩니다. 따라서 hashValue의 길이는 7로 정했습니다.
해시 함수 구현에는 '해시 후 충돌 해소' 방법과 'base62 변환' 방법 2가지에 대해 알아보겠습니다.

#### 해시 후 충돌 해소
해시 후 충돌 해소는 널리 알려진 해시 함수를 이용하는 방법입니다. 

<img width="462" height="187" alt="Image" src="https://github.com/user-attachments/assets/bd2e6a24-92e1-4135-ae93-e3755a8f0ae4" />

다만 가장 짧은 해시 값도 7보다는 깁니다. 그러므로 다음과 같은 방법으로 길이를 더 줄이게 됩니다.

<img width="674" height="423" alt="Image" src="https://github.com/user-attachments/assets/8e920e93-6816-4895-9d93-ca548690648d" />

1. 계산된 해시 값에서 처음 7개의 글자만 이용한다.
2. 만약 DB에 조회한 결과 충돌이 발생한 경우 사전에 정한 문자열을 해시값에 덧붙이고 다시 해시 함수에 입력값으로 넣는다.
3. 충돌이 발생하지 않으면 저장한다.

해당 방법은 충돌을 해소할 수 있지만, 단축 URL 생성 시 1번 이상의 데이터베이스 쿼리가 필요하므로 오버헤드가 큽니다.
데이터베이스 대신 블룸 필터를 사용하면 성능을 높일 수 있습니다.
블룸 필터는 어떤 집합에 특정 원소가 있는지 검사할 수 있는 확률론에 기초한 공간 효율이 좋은 기술입니다.

#### base-62 변환

진법 변환은 URL 단축기를 구현할 때 흔히 사용하는 접근법 중 하나입니다.
이 기법은 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야할 때 유용합니다.
hashValue에는 62개의 문자를 사용하기 때문에 base-62를 사용하도록 합니다.

<img width="536" height="235" alt="Image" src="https://github.com/user-attachments/assets/1e7e5b1c-51c0-4288-88bb-79eca9ac8709" />

### URL 단축기 상세 설계

<img width="413" height="361" alt="Image" src="https://github.com/user-attachments/assets/edfa056d-9bf5-4c0d-99ee-5acfb391daf0" />

해당 설계는 base-62 변환을 기반으로 설계한 URL 단축기입니다.
base-62에서의 ID 생성기는 전역적 유일성을 만족해야 합니다. 즉 분산 환경일지라도 생성된 ID는 유일해야만 합니다.

### URL 리디렉션 설계

<img width="540" height="248" alt="Image" src="https://github.com/user-attachments/assets/63d2f615-8957-41d3-836e-66bac88ad7e7" />

리디렉션의 경우 캐시를 활용하면 좋습니다. 쓰기보다 읽기를 더 자주 하는 시스템이므로, <단축 URL, 원래 URL> 쌍을 캐시에 저장할 시
성능의 향상을 이끌어낼 수 있습니다.

## 4단계 마무리

추가적인 논의점입니다.
- 처리율 제한 장치 : 지금까지 살펴본 시스템은 많은 요청이 밀려들 수 있으므로 처리율 제한 장치를 두는 것을 고려해볼 수 있다.
- 웹 서버의 규모 확장 : 본 설계에 포함된 웹 계층은 무상태 계층이므로, 웹 서버를 자유로이 증설하거나 삭제 가능하다.
- 데이터베이스의 규모 확장 : 데이터베이스를 다중화하거나 샤딩하여 규모확장성을 달성할 수 있다.
- 데이터 분석 솔루션 : 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 정보를 모아 데이터 분석 솔루션에 사용하면 좋을 것이다.
- 가용성, 데이터 일관성, 안정성 : ?? 당연한 얘기

## 추가 고려사항
### 스팸/피싱 위험

[네이버 me2.do 단축URL 서비스 종료 안내](https://developers.naver.com/notice/article/17062)

단축 URL 서비스를 악용한 사례가 급증하여 서비스 종료하였다는 공지사항입니다.
단축 URL을 사용한다면 유명한 단축 URL 도메인으로 위장하여 스팸/피싱 관련 사이트로 리디렉션하는 위험이 있다고 생각합니다.

### 광고형 단축 도메인 서비스

링크 주소를 짧게 변환하는 단축 도메인 서비스의 일종. 변환한 주소로 접속하면 광고를 보고난 후 목적지 링크로 이동하게 합니다.
머리 진짜 좋은 것 같습니다.

### 1글자만 바뀌어도 전혀 다른 목적지로 이동
[나무위키 단축 도메인 사건 사고](https://namu.wiki/w/%EB%8B%A8%EC%B6%95%20%EB%8F%84%EB%A9%94%EC%9D%B8#s-5)

URL을 짧게 바꿔주다보니 1글자가 더해지거나 없기만 해도 전혀 연관없는 사이트로 이동하게 되며 사건사고가 발생하는 경우도 있었습니다.


# 들어가며

`시스템 설계 면접`을 아직 경험한 적도 없고, 보통 면접이라고 하면 기술 면접, 인성 면접, 코딩 테스트 정도를 생각하는데 시스템 설계 면접은 어떤 것인지 궁금했다. 이 챕터를
읽으면서 시스템 설계 면접이 무엇인지, 어떤 식으로 준비해야 하는지에 대해 어느 정도 알게 되었다.

# 시스템 설계 면접이란?

`시스템 설계 면접`은 두 명의 동료가 모호한 문제를 풀기 위해 협력하여 그 해결책을 찾아내는 과정에 대한 시뮬레이션이다. 즉, 면접 과정에서 면접관가 지원자가 함께 시스템을
설계하는 것이므로 정해진 결말이나 정답이 존재하지 않는다. 결과를 내기 위한 과정 속에서 지원자가 어떤 식으로 문제를 접근하고 해결하는지, 그리고 그 과정에서 어떤 기술적 지식을
활용하는지를 잘 보여주는 것이 중요하다.

면접관의 일차적 목표는 지원자의 능력을 평가하는 것이다. 그러나, 지원자의 설계 능력의 기술적 측면만을 평가하는 자리라고 생각하면 오해다. 인터뷰를 진행해나가면서 지원자의 다음
요소들 또한 중요한 평가 요소가 된다.

- 협력에 적합한 사람인지
- 압박이 심한 상황에서도 잘 헤쳐 나갈 수 있는 힘이 있는지
- 모호한 문제를 건설적으로 해결할 능력이 있는지

# 효과적 면접을 위한 4단계 접근법

## 1단계: 문제 이해 및 설계 범위 확정

`시스템 설계 면접`을 볼 때, 퀴즈쇼를 맞추는 것 마냥 요구사항을 완전히 이해하지 않고 답을 내놓는 행위는 아주 부정적인 신호이다. 그러니 바로 답부터 들이밀지 말고, 속도를
늦추자. 충분히 깊게 생각하고 질문하여 요구사항과 가정들을 분명히 해야한다.

엔지니어가 가져야 할 가장 중요한 기술은 다음과 같다.

- 올바른 질문을 하는 것
- 적절한 가정을 하는 것
- 시스템 구축에 필요한 정보를 모으는 것

이렇듯, 요구사항을 정확히 이해하는 데 필요한 질문들을 통해서 시스템 설계의 범위를 확정하는 것이 중요하다. ex) 구체적인 기능 요구사항, 예상되는 트래픽, 사용하는 기술 스택
등

## 2단계: 개략적인 설계안 제시 및 동의 구하기

개략적인 설계안을 제시하고, 면접관의 동의를 얻는 행위는 마치 면접관을 팀원이라고 생각하고, 함께 설계하는 것과 같다.

- 설계안에 대한 최초 청사진을 제시하고, 의견을 구하자.
- 화이트 보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그리자.
- 시스템 규모와 관련된 제약사항들을 정리하고, 개략적인 추정을 시도해보자.

## 3단계: 상세 설계

이 단계까지 왔다면 어느 정도 청사진이 마련됐고, 시스템이 추구하는 목표 및 목적이 무엇인지에 대해서 공감대가 형성되었을 것이다. 이제는 설계 대상 컴포넌트 사이의 우선순위를
정하는 것이다. 즉, 대략적으로 생각했던 설계에 대해서 상세 설계를 하는 것이다.

이 단계에서 주의할 점은 시간 관리이다. 불필요한 세부 사항에 시간을 쓰지 말자. 또한, 면접관에게 긍정적 신호를 전달하는 데 집중하도록 하자.

## 4단계: 마무리

마무리 단계에서는 설계 결과물에 대한 몇 가지 후속 질문이 들어올 수도 있고, 던질 수도 있다. 이 단계에서는 다음과 같은 질문들을 고려해보자.

- 시스템 병목 구간 또는 더 개선 가능한 지점을 찾아내는 질문에 대해서 답변할 준비를 하자.
- 오류가 발생하면 어떤 일이 벌어질 것인지 고려해보자.
- 운영 이슈 또한 중요하고, 충분히 논의할 가치가 있다. 메트릭 수집과 모니터링 방법에 대해서 고려해보자.
- 미래에 닥칠 규모 확장 요구에 어떻게 대응할 것인지에 대해서도 생각해보자.

### 해야할 것들

- 스스로 내린 가정이 옳다 믿고 진행하지 말고, 질문을 통해서 확인하라.
- 문제의 요구사항을 명확하게 이해하자.
- 면접관과 소통하면서 사고 흐름을 이해할 수 있도록 하자.
- 가능하다면 여러 해법을 함께 제시하자.
- 개략적 설계에 면접관이 동의하면, 각 컴포넌트의 세부사항을 설명하기 시작하자. 이때 가장 중요한 컴포넌트부터 진행하자.
- 면접관의 아이디어를 이끌어 내자. 즉, 면접관 또한 같은 팀원처럼 생각하고, 함께 설계하는 것처럼 대화하자.
- 포기하지 말자.

### 하지 말아야 할 것들

- 전형적인 면접 문제들에도 대비하지 않은 상태에서 면접장에 가지 마라.
- 요구사항이나 가정들이 분명하지 않은 상태에서 설계를 제시하지 마라.
- 처음부터 특정 컴포넌트에 대해서 깊이 설명하지 마라. 개략적 설계를 마친 뒤에 상세 설계를 진행하자.
- 만약, 막혔다면 힌트를 청하기를 주저하지 말자. 즉, 침묵을 유발하지 말고, 소통하는 것을 주저하지 말자.
- 면접관이 끝났다고 말하기 전까지는 끝난 것이 아니다. 의견을 일찍, 그리고 자주 구하자.

# 시간 배분

`시스템 설계 면접`은 보통 광범위한 영역을 다루며 45분 ~ 60분이라는 시간도 부족할 수 있다. 따라서 시간 관리를 잘 하는 것도 중요하다. 45분이라는 시간이 주어졌을 때,
대략적인 시간 배분은 다음과 같다.

- 1단계: 문제 이해 및 설계 범위 확정 (3분 ~ 10분)
- 2단계: 개략적인 설계안 제시 및 동의 구하기 (10분 ~ 15분)
- 3단계: 상세 설계 (10분 ~ 25분)
- 4단계: 마무리 (3분 ~ 5분)

# 인덱스 (Index)

## 인덱스를 사용하는 이유

인덱스는 **조건을 만족하는 튜플을 빠르게 조회**하거나, `ORDER BY`, `GROUP BY` 등의 연산을 **빠르게 처리하기 위해 사용되는 데이터베이스 구조**이다. 즉,
**데이터 검색 성능을 최적화**하기 위한 필수 요소이다.

## 인덱스 분류

![Index Types](https://github.com/user-attachments/assets/4fa74871-12a6-4150-bbd4-d4b0a648052e)

- 쿼리에 맞는 적절한 인덱스를 설정해야 쿼리 성능이 개선된다.
- **옵티마이저**가 자동으로 인덱스를 선택하지만, `USE`, `FORCE` 문을 통해 직접 지정할 수도 있다.
- 단, 옵티마이저가 인덱스를 사용하는 것이 비효율적이라고 판단하면 **풀 스캔(Full Table Scan)** 전략을 사용할 수 있다.

## 인덱스를 막 생성해도 괜찮을까?

> ❌   **절대 그렇지 않다.**

- 인덱스는 SELECT 성능을 향상시켜서 조회 속도를 빠르게 해주는 것은 분명하다.
- INSERT, UPDATE, DELETE 시 **추가적인 오버헤드(갱신 비용)**가 발생하며, **저장 공간**도 차지한다.
- 따라서 **정말 필요한 인덱스만 생성하고, 사용하지 않는 인덱스는 주기적으로 제거**하는 것이 중요하다.

## Full Scan이 더 유리한 경우

- **데이터 양이 적을 경우** (수십~수백 건): 인덱스보다 **풀 스캔이 더 빠를 수 있다**
- **조회하려는 데이터의 비율이 높을 경우**: select 문법으로 조회하려는 컬럼의 개수가 많을 때, 인덱스를 통해 찾는 것보다 **테이블 전체를 읽는 것이 더 효율적**
  이다.

⚠️ 이미 데이터가 **수백만 건 이상**인 테이블에 인덱스를 생성하면 시간이 오래 걸릴 수 있고, **DB 전체 성능에 영향을 줄 수 있다.** 따라서, 시스템 설계 단계에서
미리 인덱스를 고려하는 것이 좋다. 그렇지 않을 경우에는 트래픽이 없는 시간대에 인덱스를 생성하는 것이 좋다.

## Covering Index (커버링 인덱스)

- **쿼리에서 필요한 모든 컬럼이 인덱스에 포함되어 있는 인덱스**
- **테이블을 직접 조회하지 않고 인덱스만으로 쿼리를 처리**할 수 있어 성능이 매우 향상됨
- 즉, 데이터(Clustered Index)를 조회하지 않고도 결과를 얻을 수 있다.

## Clustered Index vs Secondary Index

### Clustered Index

- 테이블의 **기본 정렬 기준**
- **Primary Key**를 기준으로 자동 생성됨
- **데이터 자체가 인덱스에 포함**

### Secondary Index (= Non-clustered Index)

- **추가로 생성되는 인덱스**
- 데이터 자체가 아닌 **포인터(주소)**를 가짐
- 조회 시 2단계 접근
    1. **Secondary Index**로 위치 찾기
    2. 해당 포인터를 이용해 **Clustered Index**를 통해 실제 데이터 접근

## 요약 ✅

| 인덱스 종류          | 설명                            |
|-----------------|-------------------------------|
| Clustered Index | Primary Key 기반, 실제 데이터와 함께 저장 |
| Secondary Index | 별도 생성, 포인터 기반 접근              |
| Covering Index  | 조회 컬럼이 모두 포함된 인덱스 (테이블 접근 없음) |

> 인덱스는 **성능 향상을 위한 도구**지만, **남용 시 성능 저하**를 일으킬 수 있다.  
> **필요한 곳에만 전략적으로** 사용하는 것이 핵심이다.

--- 

## B+ Tree 인덱스 구조

![Image](https://github.com/user-attachments/assets/8fa91b09-bbc9-44ac-8166-fb14c92bf4e4)

- 실제 DB의 인덱싱 구조는 B+ Tree 구조로 이루어져 있다.
- **정렬된 상태**로 데이터를 저장하며, Leaf 노드 간 연결리스트의 형태로 연결되어 있어 범위 검색이 효율적이다.
- B-Tree는 각 key마다 data를 저장하지만, B+ Tree는 Leaf 노드에만 데이터를 저장하고, 내부 노드는 key만 저장한다.
- 검색, 삽입, 삭제가 **로그 시간(log n)** 내 수행 가능

## MySQL의 스토리지 엔진: InnoDB

- **InnoDB는 MySQL의 기본 스토리지 엔진**이다.
- In-memory 구조로, 데이터와 인덱스를 메모리에 캐싱하기 위한 버퍼 풀이라는 저장 영역을 유지, 관리한다.
- 테이블마다 **Primary Key 기반 Clustered Index를 자동 생성**한다.
- Primary Key를 이용한 쿼리는 이 **Clustered Index**를 통해 수행된다.
- Secondary Index보다 PK (Primary Key) 기반의 Clustered Index를 우선적으로 탐색하는 경향이 존재한다.
- MVCC (Multi-Version Concurrency Control) 지원으로 **동시성 처리**가 가능하다.
    - 락을 걸지 않고 작업을 수행한다.
    - 다른 트랜잭션이 갖고있는 락을 기다리지 않고, 읽기 작업이 가능하다.

## Reference

- [인덱스 핵심 강의](https://www.youtube.com/watch?v=IMDH4iAQ6zM&t=12s)
- [B+ 트리 인덱스 구조](https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Plus-Tree)
- [MySQL과 InnoDB](https://velog.io/@byu0hyun/mysql-InnoDB%EB%9E%80)
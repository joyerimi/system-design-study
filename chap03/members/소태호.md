# 대규모 시스템 설계 면접 공략법
대규모 시스템 설계 면접에 대한 공략입니다.

### 준비하기 전 알아두기
지원자의 설계능력을 평가하는 자리가 아닙니다. 지원자가 협력이 가능한가, 압박 상황에서 문제 해결을 잘하는가,
모호한 문제에 대해 자신의 입장을 잘 표현하고 나름의 해결책을 낼 수 있는가 등을 평가하는 자리입니다.

## 4단계 접근법
### 1. 문제 이해 및 설계 범위 확정
답을 내기 전, 요구사항과 가정들을 꼼꼼히 검토해야 합니다. 빠르게 답을 내는 것이 관건이 아닙니다.
올바른 질문을 하고 적절한 가정을 하고 시스템 구축에 필요한 정보를 모아야 합니다.
정보를 얻어내기 위한 예시 질문은 다음과 같습니다.
- 구체적으로 어떤 기능을 만들어야 하는가?
- 서비스의 사용자 수는 몇인가?
- 회사의 규모는 얼마나 빠르게 성장할 것인가?
- 회사가 주로 사용하는 기술 스택은 무엇인가?

질문을 통해 요구 사항을 이해하고 모호함을 없애는 게 가장 중요합니다.

> 질문에 곁들일 수 있는 지표
> - DAU(Daily Active Users): 하루에 서비스를 이용하는 사용자 수
> - MAU(Monthly Active Users): 한 달에 서비스를 이용하는 사용자 수
> - QPS(Queries Per Second): 초당 처리되는 쿼리 수
> - TPS(Transactions Per Second): 초당 처리되는 트랜잭션 수

> 성장 지표
> - 수익 창출(Revenue Generation) : 서비스를 통해 일정 기간동안 벌어들인 총 수익
> - 활성 사용자 수(Active Users): 서비스에 일정 기간 동안 접속한 사용자 수
> - 전환율(Conversion Rate): 사용자 중 실제로 구매나 가입 등 원하는 행동을 한 사용자 비율
> - 이탈율(Churn Rate): 서비스 이용을 중단하는 사용자 비율
> - 고객 유지율(Retention Rate): 서비스 이용을 지속하는 사용자 비율
> - 전환율(Conversion Rate): 방문자가 실제로 구매나 가입 등 원하는 행동을 하는 비율 
>
> 막상 알아보고 나니 시스템 설계보다 서비스 설계에 사용될 것 같다,,,

> 비즈니스 관련 지표
> - ARPU(Average Revenue Per User): 사용자당 평균 수익
> - ARPPU(Average Revenue Per Paying User): 유료 사용자당 평균 수익
> - LTV(Lifetime Value): 고객이 서비스 생애 주기 동안 발생시키는 수익
> - CAC(Customer Acquisition Cost): 고객 1명 유치에 드는 비용
>
> 비즈니스 지표 또한 서비스 설계적인 측면이 강한 것 같다. 다만 시스템 설계에는 비용적인 측면도 고려해야 하니
> 비용 관련 질문을 하는 것도 좋을듯 하다.

### 2. 개략적인 설계안 제시 및 동의 구하기
설계에 대한 최초 제시입니다. 이 단계에서 설계의 개요를 설명하고, 면접관의 동의를 구합니다.
화이트보드나 종이를 활용하여 다이어그램을 그려 컴포넌트를 시각적으로 표현하는 것이 좋습니다.
계산 과정을 설명하며 앞서 파악한 요구사항이나 가정을 만족하는지 확인합니다.


![Image](https://github-production-user-asset-6210df.s3.amazonaws.com/91146046/458848055-ec19fdcb-5dde-460f-b942-7be905421d04.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250625%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250625T112937Z&X-Amz-Expires=300&X-Amz-Signature=909d9ad3f19d60ee5b52b302b0407601ef540473f7d05fc99c9f3ba5621087fb&X-Amz-SignedHeaders=host)


### 3. 상세 설계
이 단계까지 왔다면, 시스템 전반적으로 달성해야 하는 목표와 구현해야하는 기능 확인과 전체 설계의 토대 마련은 성공한 상태입니다.
이후 할 일은 면접관과 함께 설계에 사용된 컴포넌트 사이의 우선순위를 정하는 것입니다.
시니어급의 면접이라면 시스템의 성능 특성을 세세하게 질문할 것입니다. 설계에 대한 이유를 일목요연하게 설명하길 원할 것입니다.
주의할 점은 사소한 세부사항을 설명하느라 시간을 모두 소모해 능력을 보일 기회를 날릴 수 있습니다.


![Image](https://github-production-user-asset-6210df.s3.amazonaws.com/91146046/458850690-e997b08e-3dab-4432-8afa-7de855bff414.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250625%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250625T113633Z&X-Amz-Expires=300&X-Amz-Signature=865a2bc0deb9fb86b63c4cb819bb42308f55b7aec45246d1ba50c5d18efca888&X-Amz-SignedHeaders=host )


메세지 큐, 그래프 데이터베이스, 웹 서버에서 수행할 역할 명시, 분산 서버 도입 등 2번째 단계에서 보였던 기초 토대에
요구사항을 만족시킬 수 있는 세부사항이 늘어났습니다.

### 4. 마무리
마지막 단계에서는 면접관은 설계 결과물과 관련된 꼬리 질문을 할 수 있고, 스스로 추가 논의를 진행하도록 할 수 있습니다.
개선할 점은 언제나 존재하므로 완벽하다는 대답은 하지 맙시다.  
설계를 요약하는 것도 도움될 수 있습니다. 여러 해결책을 제시한 경우 면접관의 기억을 환기해주는 효과가 있습니다. 
트러블 슈팅, 운영 이슈, 규모 확장 가능성에 대해 논의해보는 것도 좋습니다.

### 해야할 것과 하지말아야 할 것
#### 해야할 것
- 질문을 통해 확인하기. 스스로 내린 가정이 옳다 생각하지 말기
- 요구사항을 이해하기
- 정답 혹은 최선의 답안은 없으니, 요구사항에 알맞는 해결책 제시하기
- 면접관이 내 흐름을 이해할 수 있도록 소통하기
- 다양한 해결책을 제시하기
- 개략적 설계에 동의했다면, 중요한 세부 컴포넌트부터 설명하기
- **포기하지 말기**

#### 하지말아야 할 것
- 전형적인 질문도 준비하지 않은 채 면접 참여하지 말기
- 불분명한 요구사항이나 가정이 있는 상태에서 설계 제시하지 말기
- 진행 중 막혔다면 힌트 청하기를 주저하지 말기(이건 해야하는 것 아닌가?)
- 설계안을 내었다고 면접이 끝났다고 생각하지 말기

## 설계 시 고려할 점

### 신뢰성
에러는 하드웨어나 소프트웨어, 사람의 실수로 인해 발생할 수 있습니다. 에러가 반복되면 사람들은 서비스에 대한
신뢰를 잃게 되고, 서비스를 떠나게 됩니다. 따라서 시스템 설계 시 장애가 있어도 극복할 수 있도록 설계해야 합니다.

### 확장성
소프트웨어 시스템은 끊임없이 진화합니다. 카카오톡의 경우 10만 사용자가 목표였는데 불과
6개월만에 사용자 100만 명을 돌파했습니다. 빠르게 늘어나는 사용자 부하와 주고받는 방대한 데이터를
어떻게 처리할 지 고민해야 합니다.

### 유지보수성
시스템을 한 번 개발했다고 끝나는 것이 아닙니다. 신기능은 추가하고 기존 기능이 잘 작동하도록 신경써야 합니다.
시스템이 커질수록 유지보수는 어려워집니다. 따라서 시스템이 커지더라도 유지보수하기 쉬운 구조로 설계해야 합니다.

### 참고문헌
[비즈니스 성능 지표](https://everyday-joyful.tistory.com/entry/AARRR-%EC%88%98%EC%9D%B5%ED%99%94Revenue-%EC%A3%BC%EC%9A%94-%EC%A7%80%ED%91%9CARPU-LTV-%EB%93%B1)  
[성장 지표](https://www.indeed.com/career-advice/career-development/growth-metrics)  
[시스템 설계 시 고려할 것 1](https://brunch.co.kr/@jihyun-um/43)  
[시스템 설계 시 고려할 것 2](https://deveric.tistory.com/105)  

# Index

데이터베이스에서 사용되는 인덱스란 데이터를 빠르게 조회하기 위해 사용되는 자료 구조입니다.

### Why? 사용하는가?
데이터베이스에 수천, 수만, 수백만 개의 행이 있을 때, 조건에 맞는 데이터를 찾기 위해 모든 데이터를 하나씩 확인하는 것은
비효율적입니다. 이 때 인덱스를 이용하면 매우 많은 행을 일일이 검색하지 않고 **효율적**으로 빠르게 찾을 수 있습니다.

#### 효율적?

### 어떻게 사용하는가?
인덱스는 테이블의 **하나 이상(one or more)**의 컬럼을 기반으로 생성하며,
이를 통해 무작위 조회와 정렬된 데이터 접근 모두 효율적으로 수행할 수 있습니다.
선택된 컬럼들의 데이터를 복사하여 인덱스를 생성합니다. 이 때 복사된 원본 행을 가리키는 키나 참조 정보를 포함하고 있어
전체 행을 빠르게 조회할 수 있게 해줍니다.  
일부 데이터베이스에서는 인덱싱 기능을 확장하여 함수나 표현식을 통해 변형된 컬럼 값에 대해서도 인덱스를 생성하게 해줍니다.
> 예시 : upper(last_name) 인덱스는 last_name 컬럼의 값을 대문자로 변환한 결과에 대해 인덱스를 생성합니다.


일부 데이터베이스에서는 조건에 맞는 행에만 인덱스를 생성하는 부분 인덱스(partial index)를 지원합니다.  
> `CREATE INDEX idx_active_users ON users(name) WHERE status = 'active';` 처럼, status가 'active'인 행에 대해서만 인덱스를 생성한다.


인덱스는 UNIQUE, EXCLUDE, PRIMARY KEY 등의 제약조건을 강제할 때도 사용합니다. 제약조건을 검증할 때
인덱스를 활용하면 조건에 맞는 행을 빠르게 찾을 수 있습니다.
> 예시  
> `ALTER TABLE users ADD CONSTRAINT uq_email UNIQUE (email)` : 이 경우 전체 테이블을 풀스캔하여 제약조건을 확인해야 한다.
> `CREATE UNIQUE INDEX idx_email_unique ON users(email)` : 인덱스에도 UNIQUE를 활용하여 중복 여부를 빠르게 판단 가능하다.

## 인덱스 아키텍처 및 인덱싱 메서드
### Non-clustered Index
데이터는 임의의 순서로 저장되어 있지만, 논리적인 정렬 순서는 인덱스에 의해 정의됩니다.
실제 데이터 행은 인덱싱된 컬럼이나 표현식의 값과 상관없이 테이블 전체에 흩어져 있을 수 있습니다.
인덱스 트리에는 정렬된 순서로 인덱스 키가 저장되어 있고, 리프 노드에는 해당 레코드를 가리키는 포인터가 있습니다.
이 포인터는 페이지 기반 저장 엔진에서는 데이터 페이지와 그 안의 행 번호,
파일 기반 저장 엔진에서는 파일 내의 행 위치(offset) 를 나타냅니다.


즉 데이터 행의 물리적인 저장 순서가 인덱스 정렬 순서와 다르며, 인덱싱되는 컬럼은 보통 기본키가 아닌 컬럼입니다.
`JOIN`, `WHERE`, `ORDER BY` 절에서 자주 사용됩니다. 하나의 테이블에 여러 개의 non-clustered 인덱스를 만들 수 있습니다.

> 페이지 기반 저장 엔진 vs 파일 기반 저장 엔진  
> > 페이지 기반 저장 엔진  
> > 데이터를 고정 크기의 페이지로 저장하고, 인덱스는 해당 페이지와 행 번호를 가리킨다.
> 
> > 파일 기반 저장 엔진  
> > 데이터를 하나의 연속된 파일 구조 또는 로그 구조로 저장하고 인덱스는 파일 내 위치를 가리킨다.

### Clustered Index
클러스터드 인덱스는 테이블의 데이터를 실제로 정렬하여 저장합니다. 즉, 테이블의 행이 인덱스 키의 순서대로 물리적으로 정렬되어 있습니다.
따라서 하나의 테이블에는 1개의 clustered index만 존재합니다.  
데이터를 인덱스 순서로 연속 접근하거나 범위 조회를 할 때 성능을 크게 향상시킬 수 있습니다.
물리적인 데이터가 디스크 상에 정렬되기 때문에 디스크 읽기 횟수를 줄일 수 있기 때문입니다.
실제 저장 위치를 바꿔야 하므로, 기준으로 하는 컬럼을 변경 시 I/O 작업과 CPU 부하가 발생하므로 신중하게 변경해야 합니다.

### 주의해야할 점 : 컬럼 순서
인덱스 정의 시 1개 이상의 컬럼을 사용할 수 있습니다. 인덱스의 첫 번째 컬럼만 사용해서 행을 조회하는 것은 가능하지만,
두 번째 이후 컬럼만으로 행을 식별하는 것은 불가능하거나 비효율적입니다.
![Image](https://github-production-user-asset-6210df.s3.amazonaws.com/91146046/458927968-13c7b9e5-4796-4a13-8c72-9a9b7b986f7e.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250625%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250625T144642Z&X-Amz-Expires=300&X-Amz-Signature=89466a7151425d7aeef6b12d388c94351bea268d46183f9239b6f4c8e2634aaf&X-Amz-SignedHeaders=host)
컬럼 a와 b로 인덱스를 생성한 예시입니다. a를 기준으로 정렬한 후 그 안에서 b를 기준으로 정렬합니다.
WHERE a = 7의 경우, 정렬이 되어 있어 빠른 검색이 가능하지만, WHERE b = 95의 경우, b만 보면 정렬되어 있지 않아 빠르게 검색이 힘듭니다.
따라서 성능을 개선하려면 인덱스를 생성할 때 자주 검색에 사용되는 컬럼 순서대로 생성해야 합니다.

### 적용 및 한계
`SELECT first_name FROM people WHERE last_name = 'Smith';`  
인덱스없이 해당 쿼리를 처리하려면, 테이블의 모든 행에 대해 last_name을 검사해야 할 것입니다.
이러한 방식을 풀 테이블 스캔(full table scan)이라고 하며, 처리 비용이 큽니다.

하지만 다음 쿼리는 인덱스 적용이 제한됩니다.  
`SELECT email_address FROM customers WHERE email_address LIKE '%@wikipedia.org';`  
인덱스는 일반적으로 문자열이 왼쪽에서 오른쪽으로 정렬된다고 가정하므로, 와일드카드(%)가 붙어 있어 인덱스 구조를 사용할 수 없게 됩니다.

> SARGABLE(Search ARGument ABLE) : 와일드카드가 붙어 검색할 수 없는 경우 해당 컬럼을 검색 가능하게 바꿀 수 있게 하는 것을
> SARGABLE이라고 한다.
> %abc의 경우 reverse(abc%)로 바꿔 검색할 수 있다.  
> %abc%의 경우 앞뒤 모두 와일드카드가 있다. 이런 경우 FULLTEXT 혹은 GIN, TSVECTOR같은 예약어를 사용하여 인덱스를 생성하면
> 빠르게 검색이 가능하다. LIKE '%abc%'를 완전히 대체할 수는 없으며(정확한 부분 문자열 검색은 아님) 와일드카드 문법 사용에도 제한이 있다.

### 인덱스의 종류
#### Bitmap Index
비트맵 인덱스는 컬럼의 값이 중복될 때(카디널리티가 낮은 컬럼) 효율적입니다. 예를 들어 성별을 저장하는 경우 남, 여, 미응답 3가지가 있다고 하면
최대 3개의 고유한 값을 저장하게 됩니다. 비트 논리 연산을 사용하여 쿼리를 처리하며, 공간 절약과 조회 성능이 빠르다는 장점이 있습니다.

단점으로는 데이터가 자주 갱신되는 컬럼의 경우 B-tree 인덱스보다 효율이 낮습니다. B-tree의 경우 각 행이 독립적인 인덱스 항목을 가지지만,
비트맵의 경우 다수의 행이 1개의 인덱스 블록을 공유하게 됩니다.
따라서 1개의 행만 변경하고싶어도 락이 다수의 행에 걸쳐 발생하게 되어 성능 저하가 발생할 수 있습니다.
또한 1개의 값만 바꾸면 되는 것이 아닌, 해당 컬럼을 표현한 비트맵을 모두 수정해야 하므로 쓰기 작업에서 성능이 뒤처집니다.

| Row ID | 성별 | 남자(Male) | 여자(Female) |
| ------ |----| -------- |------------| 
| 1      | 남  | 1        | 0          |         
| 2      | 여  | 0        | 1          | 
| 3      | 남  | 1        | 0          |
| 4      | 미상 | 0        | 0          |
3번의 성별을 여자로 바꾸고 싶은 경우 남자 비트맵을 0으로 바꾸는 것 뿐만아니라 여자 비트맵의 값도 1로 바꿔줘야 합니다.

#### Dense Index
데이터 파일의 모든 레코드에 대해 키와 포인터 쌍을 유지하는 인덱스입니다. 중복 키를 허용하는 클러스터드 인덱스의 경우, 해당 키를 가진
첫 번째 레코드를 가리킵니다.

#### Sparse Index
데이터 파일의 각 블록마다 키와 포인터 쌍을 포함합니다. 중복 키가 있는 클러스터드 인덱스의 경우 가장 낮은 검색 키를 가진 레코드를 가리킵니다.
Dense Index에 비해 인덱스의 크기가 상대적으로 작습니다.
또한 업데이트 시 일부 레코드에만 인덱스 엔트리가 존재하므로 인덱스 엔트리만 수정하지 않으면 인덱스 수정이 불필요하여 상대적으로 효율적입니다.

반면 데이터 블록까지만 바로 접근이 가능하여 정확한 레코드를 찾기 위해서는 블록 내에서
추가적인 탐색이 필요합니다. 
sparse index의 경우 계층을 두어 표현할 수 있는데(인덱스를 위한 인덱스) 이를 multi-level sparse index라고 합니다.
계층은 first level(inner index), second level(outer index)로 표현 가능합니다.
![Image](https://lucid.app/publicSegments/view/395be250-b56a-4507-896c-9b217e909e79/image.png)

생김새를 보면 B-tree index와 비슷한데, 멀티 레벨 인덱스의 경우 자동적으로 구조 조정이 되지 않습니다.
때문에 트리의 균형이 유지되지 않을 수 있고, 동적 확장이 어렵습니다. 이러한 한계가 있어 B-tree index가 선호됩니다.
> 언제 쓰면 좋은가?  
> 복잡하고 균형 유지 로직이 필요없는 경우 단순하고 빨라 효율적이다. 읽기 전용 혹은 거의 쓰지 않는 데이터의 경우에도 효율적이다.

#### Reverse Index
인덱스에 값을 저장하기 전에 키 값을 뒤집는 방식입니다. 예를 들어 `24538`은 `83542`로 저장됩니다.
이렇게 뒤집는 방식은 각 키 값이 이전 키 값보다 항상 큰 값이 오는 경우 유용합니다. B-tree 인덱스에서는 유사한 값이 비슷한 위치에 저장됩니다.
이 덕분에 특정 값 조회나 범위 검색에는 매우 효율적입니다.  
하지만 값이 순차적으로 삽입되는 경우 새 값을 추가하려면 항상 가장 최근의 블록에 접근해야 합니다. 여러 사용자가 동시에 삽입을 시도하면
모두 같은 블록에 접근하려 하며, 경쟁 상태가 발생하며 성능이 저하됩니다.
반면에 Reverse Index는 비슷한 새로운 값들이 인덱스 전반에 고르게 분산시키며 병목 현상을 제거합니다.
> 23456, 23457, 23458은 순차적으로 오르는 값이지만 뒤집으면 65432, 75432, 85432로 저장되어 분산이 된다.
> 65431, 75431, 85431을 뒤집은 13456, 13457, 13458의 경우 이미 한참 전에 저장된 값(값이 순차적으로 저장되는 가정)이므로
> 경쟁 상태에 지장을 주지 않는다.

#### Inverted Index
Inverted index는 주로 텍스트 검색 엔진에서 사용됩니다. 문서 내 단어와 해당 단어가 포함된 문서의 매핑을 저장합니다.

문서 데이터

| 문서 ID | 내용             |
| ----- | -------------- |
| Doc1  | "나는 사과를 좋아해"   |
| Doc2  | "사과와 바나나를 먹었어" |
| Doc3  | "바나나는 노랗다"     |

inverted index

| 단어  | 등장 문서      |
| --- | ---------- |
| 사과  | Doc1, Doc2 |
| 바나나 | Doc2, Doc3 |
| 나는  | Doc1       |
| 좋아해 | Doc1       |

문서에 대한 빠른 전체 텍스트 검색을 가능하게 하지만, 새로운 데이터를 삽입하는 것은 앞에서 봤던 인덱스보다 더 큰 비용이 필요합니다.
record-level과 word-level로 나뉘는데, record-level inverted index의 경우 각 단어에 대해 해당 단어가 포함된 문서 목록만 저장합니다.
word-level inverted index의 경우 각 단어에 대해 해당 단어가 포함된 문서와 단어 위치 정보를 저장합니다.

#### Primary Index
프라이머리 인덱스는 Primary Key 제약조건이 걸린 컬럼에 자동으로 생성되는 인덱스입니다. 대개 clustered index로 생성됩니다.
인덱스가 레코드와 직접적으로 연결되어 위치를 결정해줍니다.

#### Secondary Index
보조 인덱스라고도 하며, 정렬 기준 필드도 아니고 키 필드도 아닌 필드들을 인덱싱하는 데 사용됩니다.
파일이 키 필드나 기본 키 필드에 따라 정렬되어 있다는 보장이 없습니다.
항상 dense index로 구성되며, 인덱싱된 속성의 값과 블록 또는 레코드에 대한 포인터를 포함합니다.
> 모든 데이터에 대해 검색을 보장해야 하고, 정렬되어 있지 않으므로 dense index로 구성해야 한다.

#### hash Index
hash table을 사용하여 인덱스를 구현합니다. 시간복잡도가 O(1)로 빠른 검색이 가능합니다.
다만 rehashing에 대한 부담이 있으며, equality 비교만 가능하고 range 비교가 불가능합니다.
여러 컬럼을 사용해 인덱스를 생성하는 경우 전체 컬럼을 사용하여 조회만 가능합니다.

### Covering index
조회하려는 데이터가 index에서 모두 커버가 가능한 경우 covering index라고 합니다.
즉 원래 테이블을 볼 필요없이 지금 찾고자하는 데이터를 index에서 찾을 수 있는 상황입니다.
데이터의 조회 속도를 향상시킬 수 있지만, 인덱스 키(컬럼)가 많아질수록 인덱스의 크기가 커져 성능의 저하가 발생합니다.

### 참고문헌
[인덱스 위키피디아](https://en.wikipedia.org/wiki/Database_index)  
[10분 테코톡](https://www.youtube.com/watch?v=NkZ6r6z2pBg)  
[쉬운코드 : BJ.50 DB 인덱스(DB index) !! 핵심만 모아서 설명합니다 !! (31분이 아깝지 않을 겁니다)](https://www.youtube.com/watch?v=IMDH4iAQ6zM)  
[FULLTEXT 인덱스](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%ED%92%80%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%9D%B8%EB%8D%B1%EC%8A%A4Full-Text-Index-%EC%82%AC%EC%9A%A9%EB%B2%95)
[인덱스 구조](https://chartworld.tistory.com/18)
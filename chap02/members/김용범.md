## 들어가며

개발을 하면서 시스템 용량, 성능 요구사항에 대해서 생각해본 적이 없는 것 같다. 개발과 관련된 항목에만 집중해왔고, 어떤 시스템 성능까지 고려해가면서 개발한 경험은 없는 것
같다. 2장에서는 시스템을 구현하기에 앞서 성능이나 규모를 개략적인 수치로 추정하는 방법에 대해서 이야기한다.

## 개략적인 규모 추정

사고 실험을 행하여 추정치를 계산하는 행위로서 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것이다. 이 추정치는 시스템 설계의 초기 단계에서 이루어지며, 시스템이 처리할 수
있는 트래픽, 데이터베이스의 크기, 사용자 수 등을 고려하여 대략적인 규모를 파악하는 데 사용된다. 이러한 개략적 규모 추정을 효과적으로 해내기 위한 기본기는 다음과 같다.

1. 2의 제곱수
2. 응답지연(latency)
3. 고가용성

### 2의 제곱수

컴퓨터 세계가 2의 제곱수와 관련이 있다는 사실은 이미 알고 있었다. 1Byte가 8Bit로 이루어져 있고, 1Bit는 0과 1이라는 2가지 상태로 이루어져 있다. 이를 편하게
설명하기 위해서 보통 근사치를 활용한다. 예를 들면, 1KB는 10^3, 1MB는 10^6, 1GB는 10^9로 설명한다. 하지만, 컴퓨터 세계에서는 1KB는 2^10, 1MB는
2^20, 1GB는 2^30으로 표현한다.

| 2의 x 제곱 | 근사치                 | 이름                | 축약형 |
|---------|---------------------|-------------------|-----|
| 10      | 1천 (thousand)       | 1킬로바이트 (Kilobyte) | 1KB |
| 20      | 1백만 (million)       | 1메가바이트 (Megabyte) | 1MB |
| 30      | 10억 (billion)       | 1기가바이트 (Gigabyte) | 1GB |
| 40      | 1조 (trillion)       | 1테라바이트 (Terabyte) | 1TB |
| 50      | 1000조 (quadrillion) | 1페타바이트 (Petabyte) | 1PB |

### 응답지연(Latency)

응답지연은 시스템이 요청에 응답하는 데 걸리는 시간을 의미한다. 사용자가 시스템을 사용할 때 느끼는 지연 시간과 직결된다. 일반적으로 응답지연은 밀리초 단위로 측정되며, 낮을수록
사용자 경험이 향상된다. 우리 사용자 입장에서 생각했을 때, 당연히 로딩시간이 길어지면 바로 웹사이트를 나가는 경우도 응답지연과 관련이 깊다고 할 수 있다.

컴퓨터 연산들의 처리 속도가 어느 정도인지는 다음과 같은 표를 통해서 확인할 수 있다.

| 연산명                                | 시간                    |
|------------------------------------|-----------------------|
| L1 캐시 참조                           | 0.5ns                 |
| 분기 예측 오류(branch mispredict)        | 5ns                   |
| L2 캐시 참조                           | 7ns                   |
| 뮤텍스(mutex) 락/언락                    | 100ns                 |
| 주 메모리 참조                           | 100ns                 |
| Zippy로 1KB 압축                      | 10,000ns = 10µs       |
| 1 Gbps 네트워크로 2KB 전송                | 20,000ns = 20µs       |
| 메모리에서 1MB 순차적으로 read               | 250,000ns = 250µs     |
| 같은 데이터 내에서의 메시지 왕복 지연시간            | 500,000ns = 500µs     |
| 디스크 탐색(seek)                       | 10,000,000ns = 10ms   |
| 네트워크에서 1MB 순차적으로 read              | 10,000,000ns = 10ms   |
| 디스크에서 1MB 순차적으로 read               | 30,000,000ns = 30ms   |
| 한 패킷의 CA(캘리포니아)로부터 네덜란드까지의 왕복 지연시간 | 150,000,000ns = 150ms |

위 표를 통해서 알 수 있는 점은 다음과 같다.

1. 메모리는 빠르지만, 디스크는 아직도 느리다.
2. 디스크 탐색은 가능한 한 피하라.
3. 단순한 압축 알고리즘은 빠르다.
4. 인터넷으로 전송하기 전에 가능하면 압축하라.
5. 여러 지역으로 분산된 데이터 센터 간 데이터 전송에는 시간이 걸린다.

### 고가용성(High Availability)

고가용성은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 의미한다. 시스템 운영에 있어 정말 중요한 요소 중 하나이다. 따라서 대부분의 서비스는 99% ~
100%의 가용성을 갖는다. 100%의 가용성을 가진다는 것은 시스템이 단 한 번도 중단된 적이 없었음을 의미한다.

| 가용률      | 하루당 장애시간  | 주당 장애시간   | 개월당 장애시간 | 연간 장애시간 |
|----------|-----------|-----------|----------|---------|
| 99%      | 14.40분    | 1.68시간    | 7.31시간   | 3.65일   |
| 99.9%    | 1.44분     | 10.08분    | 43.83분   | 8.77시간  |
| 99.99%   | 8.64초     | 1.01분     | 4.38분    | 52.60분  |
| 99.999%  | 864.00밀리초 | 6.05초     | 26.30초   | 5.26분   |
| 99.9999% | 86.40밀리초  | 604.80밀리초 | 2.63초    | 31.56초  |

가용률에 9가 많을수록 시스템의 가용성이 높다고 할 수 있다. 앞으로 프로젝트를 할 때에도, 가용성을 어떻게 하면 높일 수 있는지 고민해봐야겠다.

## QPS와 저장소 요구량 측정

### QPS(Queries Per Second)

- QPS는 서버에서 초당 처리할 수 있는 쿼리의 수를 의미한다.

### 저장소 요구량 고려 요소

우선, 저장소 요구량을 추정하기 위해서는 가정, 단위를 기반으로 근사치를 계산해야 한다.

- 월간 능동 사용장(MAU): 월간에 시스템을 사용하는 사용자 수
- 일간 능동 사용장(DAU): 일간에 시스템을 사용하는 사용자 수
- 각 사용자가 시스템에 저장하는 데이터의 양: 사용자당 저장하는 데이터의 양
- 미디어 포함 데이터의 양: 이미지, 비디오 등 미디어 파일의 크기
- 데이터 보관 기간: 데이터를 얼마나 오랫동안 보관할 것인지

## 추가적인 주제 - 캐시

## 들어가며

- 캐시는 컴퓨터 구조 중 메모리 계층 구조에서 나오는 개념으로, 레지스터 다음으로 속도가 빠르지만, 용량이 작고, 비용이 비싼 메모리이다. 그만큼 중요한 정보를 담아야 되는 이
  캐시를 프로그래밍 측면에서 어떻게 활용하면 좋고, 어떤 데이터들을 어떤 방식으로 저장해서 효율적으로 사용할 수 있을지에 대해서 고민해보자.

### 캐시의 활용

"파레토의 법칙"이란 단어가 있다. 파레토의 법칙은 전체 결과의 80%가 원인의 20%에서 발생한다는 이론이다. 캐시를 활용하는 이유도 이와 비슷하다. 전체 데이터 중에서 자주
사용되는 데이터의 양이 전체 데이터의 20%에 불과하지만, 이 데이터가 전체 시스템 성능에 미치는 영향은 80%에 달한다. 따라서, 자주 사용되는 데이터를 캐시에 저장함으로써
시스템 성능을 향상시킬 수 있다.

여기서 생겨난 단어가 있는데, 그것은 바로 "**Cache Hit Rate**"이다. 캐시 히트율은 캐시에서 데이터를 성공적으로 찾은 비율을 의미한다. 높은 캐시 히트율은 시스템
성능을 향상시키는 데 중요한 요소이다. 반대로 "**Cache Miss Rate**"는 캐시에서 데이터를 찾지 못한 비율을 의미한다. 캐시 미스율이 높으면 그만큼 해당 데이터를
메인 메모리나 하드 디스크에 있는지 찾아야 하기 때문에 시스템 성능이 저하될 수 있다. 따라서 적절한 캐시 데이터와 캐시 크기, 캐시 교체 알고리즘을 선택하는 것이 중요하다.

### 캐시의 종류

캐시의 종류는 다음과 같다.

- Local Cache: 애플리케이션 서버의 메모리에 저장되는 캐시로, 빠른 접근 속도를 제공한다.
    - 장점: 서버간 통신이 없으므로, 속도가 빠르다.
    - 단점: 서버가 여러 대일 경우, 각 서버마다 캐시가 따로 관리되므로, 데이터 일관성 유지가 어렵다.
- Web Cache: 웹 사용자에 의해 빈번히 요청되는 데이터를 웹캐시 서버(Nginx 등)에 저장하여, 실제 server에 요청을 보내지 않고도 빠르게 응답할 수 있도록 한다.
    - 장점: 요청이 실제로 서버로 넘어가지 않기 때문에 서버의 부하를 줄이고, 사용자에게 빠른 응답을 제공한다.
    - 단점: 중간에 별도의 Proxy 서버를 두게 되어 캐시된 데이터가 없을 경우 통신 시간이 늘어나게 된다.
- Redis Cache: 데이터 영속성을 지원하는 In-Memory 데이터베이스로, 데이터를 메모리에 저장하고, 필요할 때 빠르게 접근할 수 있도록 한다.
    - 장점: 빠른 읽기/쓰기 속도와 다양한 데이터 구조를 지원하여 캐시로서의 역할을 잘 수행한다.
    - 단점: Local Cache에 비해 서버 <-> Redis 서버 간 통신이 필요하므로, 비용과 속도 측면에서 불리할 수 있다.

### Redis(Remote Dictionary Server)

Redis는 Remote Dictionary Server의 약자로, 오픈소스 인메모리 데이터 구조 저장소이다. Redis는 키-값 저장소로, 데이터를 메모리에 저장하고, 필요할 때
빠르게 접근할 수 있도록 한다. Key-value DB 중 압도적인 사용량 1위를 차지하고 있다.

![Redis Ranking](https://github.com/user-attachments/assets/33be3641-35ee-4aba-b402-4a8f6ae2e2cc)

Redis는 메모리 기반 오픈소스 NoSQL DBMS의 일종으로, 웹 서비스에서 캐싱을 위해 주로 사용된다. Redis는 빠른 읽기/쓰기 속도와 다양한 데이터 구조를 지원하여
캐시로서의 역할을 잘 수행한다. Redis는 키-값 저장소로, 데이터를 메모리에 저장하고, 필요할 때 빠르게 접근할 수 있도록 한다.

## 캐싱 전략 패턴

캐싱 전략 패턴에는 크게 "캐시 읽기 전략"과 "캐시 쓰기 전략"이 있다.

### 캐시 읽기 전략

- **Look-Aside 패턴**:
    - 데이터를 찾을 때, 우선 캐시에 저장된 데이터가 있는지 우선적으로 확인하는 전략이다. 만일 캐시에 데이터가 없다면 DB에서 조회한다. 이 방법은 반복적인 읽기가 많은
      경우에 적합하다. 서버를 처음 띄우게 되면 캐시는 비어있기 때문에 Cache Hit Rate가 0이다. 따라서 Look-Aside 패턴을 사용한다면, 캐시에 미리
      데이터를 채워놓는 **Cache Warming** 작업을 수행하는 것이 좋다.

- **Read-Through 패턴**:
    - 캐시에서만 데이터를 읽는 전략이다. 이 패턴을 사용하게 되면 Cache와 DB의 일관성을 유지하지 않아도 되지만, Redis와 같은 캐시 서버가 장애가 났을 경우,
      서비스 장애로 이어진다.

### 캐시 쓰기 전략

- **Write-Back 패턴**:
    - 데이터 저장 시, DB에 바로 쓰지 않고, 캐시에 모아서 일정 주기 배치 작업을 통해 DB에 반영하는 전략이다. 쓰기 쿼리 비용과 부하를 최소화할 수 있다. 데이터
      정합성이 확보되지만, 캐시에서 오류가 발생하면 데이터가 손실되는 단점이 있다.

- **Write-Through 패턴**:
    - 데이터 저장 시, 캐시에 저장한 다음 바로 DB에 반영하는 전략이다. 이 역시도 Write-Back 패턴과 마찬가지로 데이터 정합성이 확보되지만, 매 요청마다 쓰기
      요청이 2번씩 발생하기 때문에 성능 이슈가 존재한다. 하지만, 캐시나 DB 중 하나가 장애가 발생하더라도 데이터 손실이 없다는 장점이 있다.

- **Write-Around 패턴**:
    - 모든 데이터를 DB에 저장하는 전략이다. Cache에서 데이터를 찾지 못하는 경우에 DB에서 Cache로 데이터를 저장한다. 이 패턴은 Cache와 DB 간 데이터
      정합성에 문제가 생길 수 있다.

### 자주 쓰이는 패턴

- **Look-Aside 패턴** + **Write-Around 패턴**
    - ![Image](https://github.com/user-attachments/assets/a075fc5b-ccc6-4894-9f9a-a9e6c4f34897)
    - 가장 일반적으로 자주 쓰이는 조합이다. 모든 데이터를 DB에 저장하고, 캐시에서 데이터를 찾지 못하는 경우에 DB에서 데이터를 조회하여 캐시에 저장한다. 이 패턴은
      캐시와 DB 간 데이터 정합성을 유지하면서도, 캐시의 Hit Rate를 높일 수 있다.

- **Read-Through 패턴** + **Write-Around 패턴**
    - ![Image](https://github.com/user-attachments/assets/9fa7f80f-6b72-419a-999e-7961af0ef7dd)
    - 항상 DB에 쓰고, 캐시에서 데이터를 읽을 때, 항상 DB에서 먼저 읽어오므로 데이터 정합성 이슈에 대한 완벽한 안전 장치를 구성할 수 있다.

- **Read-Through 패턴** + **Write-Through 패턴**
    - ![Image](https://github.com/user-attachments/assets/b7327a2c-9b4f-4075-8c23-d67edb52aa37)
    - 데이터를 쓸 때, 항상 캐시에 먼저 쓰므로, 읽어올 때 항상 최신 캐시 데이터를 보장한다. 데이터를 쓸 때, 항상 캐시에서 DB로 보내므로 데이터 정합성에도 문제가
      없다.

## Redis 백업 복구 전략

Redis는 데이터를 메모리에 저장하기 때문에, 서버가 재시작되거나 장애가 발생하면 데이터가 손실될 수 있다. 이를 방지하기 위해 Redis는 다음과 같은 백업 복구 전략을
제공한다.

### RDB 스냅샷

RDB 스냅샷은 Redis의 데이터를 주기적으로 디스크에 저장하는 방식이다. 이 방식은 Redis 서버가 재시작되거나 장애가 발생했을 때, 마지막으로 저장된 스냅샷을 사용하여
데이터를 복구할 수 있다.

- 장점
    - 빠른 복구 속도: RDB 파일은 바이너리 형식으로 저장되므로, 복구 속도가 빨라 백업에 효과적이다.
    - 스냅샷을 매일 저장하는 것이 가능하다.
    - 장애 시, 다양한 데이터 버전들을 손쉽게 복구할 수 있다.
- 단점
    - 최신 데이터의 손실이 발생할 수 있다. 즉, RDB 스냅샷은 주기적으로 저장되므로, 마지막 스냅샷 이후에 변경된 데이터는 손실될 수 있다.

### AOF(Append Only File)

AOF(Append Only File)는 Redis의 모든 쓰기(write & update) 작업을 로그 파일에 기록하는 방식이다. 이 방식은 Redis 서버가 재시작되거나 장애가
발생했을 때, AOF 파일을 사용하여 데이터를 복구할 수 있다.

- 장점
    - 다양한 fsync 정책으로 높은 내구성을 가진다. fsync 정책은 AOF 파일을 디스크에 기록하는 빈도를 조절하는 방법으로, fsync를 매 쓰기 작업마다 수행하거나,
      일정 시간마다 수행할 수 있다.
- 단점
    - AOF 파일은 RDB 파일보다 크므로, 복구 속도가 느릴 수 있다.
    - AOF 파일은 모든 쓰기 작업을 기록하므로, 디스크 I/O 부하가 증가할 수 있다.

### RDB와 AOF의 조합

결론적으로는 AOF를 기본으로 하고, RDB를 보조로 사용하는 것이 좋다. AOF는 모든 쓰기 작업을 기록하므로, 데이터의 내구성이 높고, RDB는 빠른 복구 속도를 제공한다.
따라서, AOF와 RDB를 조합하여 사용하면 데이터의 내구성과 복구 속도를 모두 확보할 수 있다.

## Redis의 활용

- 캐싱(Cashing): 임시 비밀번호(One-Time Password, OTP), 로그인 세션, JWT, 일정 주기로 갱신해도 괜찮은 데이터, 동일한 연산에 따른 결과 등을
  캐싱하여 성능을 향상시킨다.
- 실시간 분석: 순위(Rank), 실시간 이벤트 로그 처리, 방문자 수 계산 등 실시간으로 데이터를 분석하고 처리하는 데 사용된다.
- Pub/Sub 시스템: Redis는 Publish/Subscribe 모델을 지원하여, 실시간 알림 시스템이나 메시징 시스템을 구축하는 데 사용된다.
- 큐(Queue): Redis는 리스트(List) 자료구조를 사용하여 작업 큐를 구현할 수 있다. 작업을 큐에 추가하고, 소비자가 작업을 처리하는 방식으로 비동기 처리를
  지원한다.
- Global Lock: Redis는 분산 환경에서의 글로벌 락을 구현하는 데 사용될 수 있다. 여러 서버 간에 공유되는 리소스에 대한 동기화를 지원한다.
    - Redisson Lock: Redis를 이용한 분산 락 구현 라이브러리로, Redisson을 사용하여 글로벌 락을 구현할 수 있다. Redisson은 Redis의 다양한
      기능을 활용하여 분산 환경에서의 동기화를 지원한다.
    - Lettuce Lock: Lettuce는 Redis 클라이언트 라이브러리로, 비동기 및 동기 방식으로 Redis에 접근할 수 있다. Lettuce를 사용하여 글로벌 락을
      구현할 수 있다.

### References

- [캐시 개념](https://mangkyu.tistory.com/69)
- [캐시 종류](https://developer-jiing.tistory.com/50)
- [10분 테코톡 - 큰곰의 Cache](https://www.youtube.com/watch?v=c33ojJ7kE7M)
- [DB-Engines Ranking of Key-value Stores](https://db-engines.com/en/ranking/key-value+store)
- [캐싱 전략 패턴 정리](https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC)

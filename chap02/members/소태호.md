# 개략적인 규모 추정

개략적인 규모 추정이란 우리의 서비스에서 측정한 성능 수치를 가지고 추정치를 사람이 계산하는 것입니다.
효과적인 추정을 하기 위해서는 어떤 규모가 어느 정도의 퍼포먼스를 낼 수 있는지 판단할 수 있는 기본기가 필요합니다.

## 2의 제곱수
데이터의 볼륨을 계산하는 데 사용되는 가장 기본입니다.

| 단위 (약어) | 크기 (바이트)            | 근사치 (10진수 기준)         | 근사치 (2진수 기준)               |
|-------------|--------------------------|-------------------------------|-----------------------------------|
| 1 KB        | 1,000                    | 10³                           | 1,024 (2¹⁰)                       |
| 1 MB        | 1,000,000                | 10⁶                           | 1,048,576 (2²⁰)                   |
| 1 GB        | 1,000,000,000            | 10⁹                           | 1,073,741,824 (2³⁰)               |
| 1 TB        | 1,000,000,000,000        | 10¹²                          | 1,099,511,627,776 (2⁴⁰)           |
| 1 PB        | 1,000,000,000,000,000    | 10¹⁵                          | 1,125,899,906,842,624 (2⁵⁰)       |

## 응답 지연값

캐시 - 메모리(RAM) - 주 메모리(HDD, SDD) 순으로 응답에 시간이 많이 걸리며,
캐시 참조와 주 메모리 참조의 시간을 비교해보면 L2 캐시여도 14 ~ 15배의 차이가 있습니다.
디스크 탐색 피하기, 압축하여 네트워크로 전송하기 등 프로그래머가 주의를 기울이면 지연을 단축시킬 수 있는 요소도 있습니다.

### 컴퓨터 아키텍처 설계 원칙

| 번호 | 원칙 (영문)                      | 원칙 (한글)                     | 주요 내용 |
|------|----------------------------------|----------------------------------|-----------|
| 1    | Make the Common Case Fast        | 자주 발생하는 경우를 빠르게 만들어라 | 대부분의 프로그램에서 자주 사용되는 연산이나 데이터 접근 방식을 최적화하여 전체 시스템 성능을 크게 향상시킵니다. (예: 레지스터 사용) |
| 2    | Smaller is Faster                | 작을수록 빠르다                  | 물리적인 제약으로 인해 더 작은 하드웨어는 신호를 더 빠르게 전달하고, 전력 소모 및 비용이 적게 듭니다. (예: 작은 레지스터 파일, 캐시 메모리) |
| 3    | Simplicity Favors Regularity     | 단순함은 규칙성을 선호한다       | 설계를 단순하고 규칙적으로 만들면 구현이 용이하고, 오류 발생 가능성이 줄어들며, 유지보수가 쉬워집니다. (예: 고정 길이 명령어, 규칙적인 명령어 형식) |
| 4    | Good Design Demands Good Compromises | 좋은 설계는 좋은 타협을 요구한다 | 성능, 비용, 전력, 면적 등 주어진 제약 조건 내에서 모든 원칙을 완벽히 만족시키기 어렵기 때문에 최적의 균형점을 찾는 것이 중요합니다. (예: MIPS 명령어 집합 설계) |
| 5    | Performance via Parallelism      | 병렬성을 통한 성능 향상          | 단일 프로세서의 한계를 극복하기 위해 여러 작업을 동시에 처리하여 성능을 향상시킵니다. (예: 멀티코어 프로세서, SIMD) |
| 6    | Performance via Pipelining       | 파이프라이닝을 통한 성능 향상     | 명령어 실행 단계를 분할하고 각 단계를 병렬적으로 수행하여 명령어 처리율(throughput)을 높이는 기법입니다. (예: 명령어 파이프라인) |
| 7    | Performance via Prediction       | 예측을 통한 성능 향상            | 미래의 동작(특히 분기)을 미리 예측하여 대기 시간을 줄이고 성능을 향상시킵니다. (예: 분기 예측) |
| 8    | Hierarchy of Memories            | 메모리 계층 구조                 | 빠르고 비싼 메모리(캐시)부터 느리고 저렴한 메모리(하드 디스크)까지 다양한 속도와 용량의 메모리를 계층적으로 구성하여 전반적인 메모리 접근 성능을 최적화합니다. |
| 9    | Dependability via Redundancy     | 중복성을 통한 신뢰성 확보        | 하드웨어 고장에 대비하여 시스템의 신뢰성을 높이기 위해 중복성(Redundancy)을 활용합니다. (예: RAID 시스템, 이중화된 전원 공급 장치) |

## 가용성에 관계된 수치들
고가용성(high availability)이란 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭하는 용어입니다.
100%는 한 번도 중단된 적이 없음을 의미합니다. 대부분의 서비스는 99% ~ 100% 사이를 유지합니다.
서비스 제공자들은 SLA라는 용어를 사용해서 가용률을 표현합니다.
가용률 99%의 경우 하루당 장애시간이 14.40분, 99.9%의 경우 1.44분입니다. 아마존, 구글, 마이크로소프트의 경우 99%이상의 가용률을 제공합니다.

> 하루당 장애시간이 1시간인 경우 SLA가 약 95.83%라고 한다.

## 팁

규모 추정은 올바른 절차를 밟는 것이 결과를 내는 것보다 중요합니다. 다음은 문제를 해결할 때 사용하기 좋은 팁입니다.

1. 근사치를 활용한 계산 : 계산의 정확함을 요구하는 게 아니므로 근사치를 활용하자.
2. 가정들은 적어두기
3. 단위를 붙이기 : KB, MB 등 헷갈리지 않도록 단위를 잘 기록해두자.
4. 연습 많이하기

# 캐시

### 캐시란?
컴퓨터 시스템에서 속도가 느린 장치와 빠른 장치 사이의 병목을 줄이기 위해 사용하는 임시 저장소입니다.

### ✅ 다양한 종류의 캐시
- CPU 캐시: 프로세서 연산 속도 향상을 위해
- 디스크 캐시: 디스크 I/O 속도 개선
- 브라우저 캐시: 웹사이트 재방문 시 빠르게 표시
- DB 캐시 (예: Redis): 데이터베이스 부하 감소 및 응답 속도 향상

# 브라우저 캐시
웹브라우저도 마찬가지로 요청할 때마다 재사용 가능한 리소스까지 요청한다면 낭비가 발생할 수 있습니다.
이런 낭비를 막기 위해서 브라우저에서도 캐시를 사용할 수 있습니다.
HTTP의 `cache-control` 헤더를 이용하여 캐시의 기능을 활용할 수 있습니다.

## HTTP 캐시 제어

캐시 제어 헤더에는 3가지가 있습니다.
1. cache-control : HTTP/1.1에서 도입된 캐시 정책 제어용 헤더
2. Pragma : HTTP/1.0 하위 호환을 위해 사용하는 캐시 제어 헤더. cache-control과 동일한 역할을 수행하지만 사용이 권장되지 않는다.
구식이기도 하며 cache-control의 경우 서버 - 클라이언트 환경에서 요청/응답 모두 사용이 가능하지만, 요청 헤더로만 만들어 졌기 때문이다.
결정적으로 pragma는 no-cache 옵션만 있고 세밀한 캐시 전략을 세울 수 없다.
3. Expires : 캐시의 만료일을 명시하는 헤더. cache-control 헤더에 max-age로 유효 시간을 명시하는 게 추천되므로 하위 호환을 위해 사용된다.
max-age와 동시에 사용되면 Expires는 무시된다.

### cache-control의 옵션
콤마(,)를 사용해 열거하여 여러 옵션을 중복하여 적용이 가능합니다.

| 디렉티브               | 설명                                                                     |
| ------------------ |------------------------------------------------------------------------|
| `no-cache`         | **캐시해도 되지만**, 매 요청 시 서버에 유효성 검사(재검증)를 거쳐야 함. 완전한 비캐시는 아님.              |
| `no-store`         | **캐시 미허용**. 민감한 정보(예: 로그인 정보, 카드 정보 등)에 사용. 브라우저와 프록시 모두 저장 불가.        |
| `max-age=<초>`      | 리소스를 **최대 몇 초 동안 유효한 캐시로 인정할지**를 지정. 그 안엔 검증 없이 사용함. (예: `max-age=3600` → 1시간) |
| `s-maxage=<초>`     | **공용 캐시(예: CDN, 프록시)** 전용 `max-age`. `max-age`보다 우선함.                  |
| `public`           | 공용 캐시(예: 프록시)도 이 응답을 캐시할 수 있음을 의미. 로그인 없이 접근 가능한 리소스에 사용.              |
| `private`          | **브라우저 캐시만 허용**. 사용자별 데이터(예: 마이페이지 등)에 사용.                             |
| `must-revalidate`  | 캐시가 만료되면, **꼭 서버에 재검증**하고 나서야 사용 가능. 클라이언트가 만료된 캐시를 임의로 사용하지 못함.       |
| `proxy-revalidate` | `must-revalidate`와 유사하지만, **공용 캐시에만 적용**됨.                             |
| `immutable`        | 캐시된 리소스가 **절대 바뀌지 않는다고 보장**. 브라우저가 재검증 요청조차 안 함. (ex: 빌드된 JS/CSS에 좋음)  |
| `no-transform`     | 프록시나 CDN이 이미지/리소스를 **압축하거나 변형하지 말라**는 의미. (화질 유지 필요할 때 사용)             |


## HTTP 캐시 검증 / 조건부 요청

1MB의 사진을 보내달라고 서버에 요청한다고 가정해봅시다. 이 사진은 얼마의 시간동안 캐시로 남아있어도 괜찮을까요?
> "캐시를 얼마나 유지해야하는가?"에는 답이 없다. 데이터의 변경 빈도, 종류, 사용자같은 요소를 검토하여 적절한 시간을 매겨야 한다.

그런데 만약 캐시의 유효 시간이 끝나지 않았는데 서버의 데이터가 업데이트 되었다면 브라우저에 있는 캐시와 서버의 데이터가 불일치하는 현상이 발생하게 됩니다.
HTTP 헤더에는 데이터 불일치를 확인하기 위한 `Last-Modified`, `Etag` 헤더를 제공해줍니다.
또한 데이터 불일치를 확인할 수 있다면 변경되지 않았지만 만료된 리소스에 대해서도 무조건 새로 요청하는 것이 아닌 간단한 검사만 하고 캐시를 활용할 수 있습니다.

### Last-Modified
서버가 리소스를 마지막으로 수정한 날짜를 응답 헤더에 포함할 때 사용합니다. `If-Modified-Since` 옵션과 함께 사용하여
클라이언트가 이전에 받은 수정 시간을 보내고, 서버가 그 이후에 변경된 경우에만 새 응답을 보냅니다. 그렇지 않은 경우는 304 not-modified를 반환합니다.

요청예시
```http request
GET /news.html HTTP/1.1
If-Modified-Since: Tue, 18 Jun 2024 10:00:00 GMT

HTTP/1.1 304 Not Modified
```

#### 단점
1. 1초미만 단위의 캐시 조정이 불가능하다.
2. 날짜 기반 로직의 한계가 있다. txt파일의 내용을 수정한 후 롤백을 하면 내용은 그대로지만, 수정 시간은 변경되어 새로 다운로드해야 한다.
3. 서버에서 별도의 캐시 관리 로직을 만들기 어렵다.

### Etag
서버가 리소스의 버전을 식별하는 고유 값을 응답 헤더에 포함할 때 사용합니다. `If-None-Match` 옵션과 함께 활용되며
클라이언트가 서버에 이전에 받은 Etag값을 보내고 Etag가 같으면 304 not-modified, 다르다면 새 리소스를 응답합니다.
Etag값은 해시값, UUID 등을 이용합니다.

요청예시
```http request
GET /logo.png HTTP/1.1
If-None-Match: "abc123"

HTTP/1.1 304 Not Modified
```

두 헤더를 모두 사용했을 때 서버의 응답 예시
```http request
HTTP/1.1 200 OK
ETag: "xyz789"
Last-Modified: Wed, 12 Jun 2024 12:30:00 GMT
Cache-Control: no-cache
```

쓰기 요청의 경우 `If-Modified-Since`, `If-None-Match`의 반대 역할을 하는 `If-Match`, `If-Unmodified-Since`를 사용하여 리소스가 안바뀌었는지 확인하여 덮어쓰거나 실수로 삭제하는 일을 방지할 수 있습니다.
만약 캐시 데이터의 정보가 일치하지 않는다면 412 Precondition Failed을 반환하여 동시성 제어 혹은 덮어쓰기 방지가 가능합니다.

## 프록시 캐시

CDN과 비슷한 원리입니다. 기존 백엔드 서버가 위치한 지점과 클라이언트가 통신하면 1초가 걸린다고 가정했을 때, 
클라이언트와 가까운 위치에 프록시 캐시 서버를 두어 통신에 걸리는 지연 시간을 줄여줍니다.
> private vs public
> > 클라이언트의 브라우저에 저장되는 캐시를 private 캐시, 프록시 캐시 서버에 저장되는 프록시 캐시를 public 캐시라고 한다.
> > 이는 cache-control 헤더의 옵션 `public`, `private`을 이용하여 조정할 수 있다.

## HTTP 캐시 무효화

![Image](https://github-production-user-asset-6210df.s3.amazonaws.com/91146046/456684724-441237bd-bcb9-44bd-a58c-bad5901d7ca8.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20250618%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250618T193939Z&X-Amz-Expires=300&X-Amz-Signature=0d8dd150c256b55822661a1ec79ab616cac89fd56c0f4de6d14695a8285e284b&X-Amz-SignedHeaders=host)

브라우저의 캐시를 완전히 제거 해버리는 것입니다. 최신 데이터로 바꿔주거나, 데이터 일관성 유지를 하기 위해 필요합니다.

### 캐시 무효화 헤더

cache-control의 `no-cache`, `no-store`, `must-revalidate`같은 옵션을 사용해서 캐시를 무효화시킬 수 있습니다.
> `no-cache` vs `no-store`
> > `no-cache`는 일단 캐시로 저장한다. 대신 서버에 먼저 요청을 보내 304 요청을 받은 후 캐시에서 사용한다.
> `no-store`는 무조건 캐시를 저장하지 않는다. 민감한 정보에 사용한다.

> `no-cache` vs `must-revalidate`
> > 프록시 캐시 서버를 사용하는 경우에 두 옵션의 차이점이 생긴다.
> > `no-cache`의 경우 원래 서버에 접근이 불가능해질 경우 검증을 거치지 않고 이전의 캐시 데이터를 반환한다.
> > `must-revaildate`의 경우 원 서버를 통해 검증을 받지 못한 경우 504 Gateway Timeout을 반환한다.
> > 대신 `must-revalidate`만 사용하는 경우 캐시 유효 시간이 남아 있다면 캐시 저장소를 조회하게 되므로
> > 따라서 프록시 캐시 서버를 사용하며 검증을 받아야 하는 경우 두 옵션 모두 사용하여 별도의 재수정 로직을 거치게 할 수 있다.




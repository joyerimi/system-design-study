# 들어가며

6장 내용은 `키-값 저장소 설계`이다. 어떤 내용일까? 먼저 생각해보자. 내가 아는 키-값 저장소는 Redis, Memcached 등이 있다. 이들은 빠른 데이터 접근을 위해
메모리에 데이터를 저장하는 구조로, 대규모 트래픽을 처리하는 데 유용하다. 이 정도 베이스 지식을 가지고, 6장을 읽어보도록 하자.

# Key - Value

- 고유 식별자인 키를 가진다. 이 키는 유일해야 하며, 일반 텍스트일 수도 있고, 해시 값일 수도 있다.
- 성능 상의 이슈로 키는 짧을수록 좋다.
- Value는 키에 대응하는 데이터로, 문자열, 리스트, 객체가 올 수 있다.

# 단일 서버 Key - Value 저장소

- 단일 서버 환경에서 키-값 쌍 전부를 메모리에 해시 테이블로 저장하면 되므로, 구현이 쉽다.
- 그러나, 그만큼 데이터를 메모리에 저장하기 때문에 언젠가는 반드시 한계에 직면한다.
- 이런 경우, 자주 쓰이는 데이터만을 메모리에 저장하고, 나머지 데이터는 디스크에 저장하는 방식을 통해 개선할 수 있지만, 여전히 한계가 있다.

# 분산 서버 Key - Value 저장소 (= 분산 해시 테이블)

분산 시스템을 설계할 때에는 CAP 정리를 이해하고 있어야 한다.

## CAP 이론

<img width="1164" height="664" alt="Image" src="https://github.com/user-attachments/assets/fb8b8b3b-a8be-44e8-aac1-f4ee1e6fe564" />

CAP 이론은 분산 시스템에서 세 가지 속성(일관성, 가용성, 파티션 내구성) 중 두 가지만을 동시에 만족할 수 있다는 이론이다. 왜 2가지만을 만족할 수 있을까? 그것은 바로
Partition Tolerance 때문이다. 네트워크가 분할되면, 시스템은 일관성(consistency)과 가용성(availability) 중 하나를 포기해야 한다.

### Consistency (= 데이터 일관성)

- 분산 시스템에서 어떤 노드에 데이터를 읽더라도 언제나 같은 데이터를 반환해야 한다.

### Availability (= 가용성)

- 분산 시스템에서 일부 노드에 장애가 발생하더라도, 항상 응답을 받을 수 있어야 한다.

### Partition Tolerance (= 파티션 내구성)

- 분산 시스템에서 도 노드 사이에 통신 장애가 발생하더라도, 시스템은 계속 동작하여야 한다.

## CAP 이론의 활용

### CP 시스템

- Consistency와 Partition Tolerance를 만족하는 시스템이다. 가용성을 희생한다.

### AP 시스템

- Availability와 Partition Tolerance를 만족하는 시스템이다. 일관성을 희생한다.

### CA 시스템

- Consistency와 Availability를 만족하는 시스템이다. Partition Tolerance를 희생한다. 그러나, 현실적으로는 네트워크 장애가 발생할 수 있기
  때문에, CA 시스템은 존재하지 않는다.

### 이상적 환경과 현실 환경

만약, 네트워크 통신 장애가 발생하지 않는 환경이라면 CAP 이론을 모두 만족하는 시스템을 만들 수 있을 것이다. 하지만, 실제 현실 환경에서는 네트워크 파티션 문제를 피할 수
없기 때문에 CAP 이론 중 P는 반드시 가져가야 하고, 나머지 A, C 중 하나를 선택해야 한다.

AP 시스템은 일관성 대신 가용성을 선택한 시스템이므로, 가장 최신의 데이터를 반환하지 않을지라도 계속 읽기 연산을 허용해야한다. 반대로 CP 시스템은 가용성 대신 일관성을 선택한
시스템으로, 가장 최신의 데이터로 각 노드들끼리 동기화가 되어있지 않다면 쓰기 연산을 거부해야 한다.

<img width="1168" height="541" alt="Image" src="https://github.com/user-attachments/assets/f9359e9a-71e5-42cd-a61b-a16c653d657b" />

## 키-값 저장소 구현 관련 시스템 컴포넌트

다음은 키-값 저장소 구현에 사용될 핵심 컴포넌트들 기술들이다. 쭉 살펴보도록 하자.

- 데이터 파티션
- 데이터 다중화
- 일관성
- 일관성 불일치 해소
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로
- 읽기 경로

### 데이터 파티션

전체 데이터를 한 대 서버에 넣는 것은 불가능하다. 따라서 가장 간단하게 생각해 볼 수 있는 부분은 데이터를 여러 서버에 나누어 저장하는 것이다. 이를 데이터 파티션이라고 한다.
따져야 할 부분은 다음과 같은 2가지이다.

- 데이터를 여러 서버에 고르게 분산할 수 있는가?
- 노드가 추가되거나 삭제 될 때, 데이터의 이동을 최소화할 수 있는가?

이 2가지를 충족시킬 수 있는 방법으로 5장에서 공부한 `안정 해시` 기법이다.

![Image](https://github.com/user-attachments/assets/6382cb18-0a1a-4ad5-9c6c-94dad633c07f)

어떤 키값에 대해서 어떤 서버에 저장할 지 결정하기 위해서는 해시 링 위에 해당 키값이 위치한 곳에서 시계 방향으로 가장 처음 만나는 서버에 데이터를 저장한다. 이처럼 안정 해시
기법을 사용해서 데이터를 파티션 하면 `규모 확장 자동화`, `다양성` 측면에서 좋다.

- 규모 확장 자동화: 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제되도록 만들 수 있다.
- 다양성: 각 서버 상황에 맞게 가상 노드의 수를 조정할 수 있다.
    - 고성능 서버는 가상 노드를 많이 가질 수 있는데, 가상 노드가 많으면 키의 분포가 균등해지고, 그에 따라 데이터를 고르게 분포시킬 수 있다.

### 데이터 다중화

### 일관성

### 일관성 불일치 해소

### 장애 처리

### 시스템 아키텍처 다이어그램

### 쓰기 경로

<img width="1245" height="618" alt="Image" src="https://github.com/user-attachments/assets/b21883a4-4ff1-4b6a-aa99-ea4c0afc7ec6" />

쓰기 경로의 플로우는 다음과 같다

1. 쓰기 요청이 커밋 로그 파일에 기록된다.
2. 데이터가 메모리 캐시에 기록된다.
3. 메모리가 가득 차거나, 어떤 임계치에 도달하면 데이터는 디스크의 SSTable(Sorted-String Table)에 기록된다.
    - 이때, SSTable은 정렬된 문자열 테이블로, 키-값 쌍을 저장하는 파일이다.

### 읽기 경로

![Image](https://github.com/user-attachments/assets/ce58eb00-26a4-4362-95f1-dc118422c7e6)

읽기 경로의 플로우는 다음과 같다.

1. 우선, 메모리 캐시를 먼저 읽어서 해당 데이터가 존재한다면 바로 클라이언트에게 반환한다.
2. 데이터가 메모리에 없다면 블룸 필터를 사용하여 해당 키가 SSTable에 존재하는지 확인한다.
3. SSTable에 존재한다면, 해당 SSTable을 디스크에서 읽어와 데이터를 반환한다.
4. 만약 SSTable에 존재하지 않는다면, 클라이언트에게 데이터가 없다는 응답을 반환한다.

## 마무리

- 너무 어렵다.
# 키 - 값 저장소 설계
키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스입니다.
이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 합니다.
키와 값의 이런 관계를 "키-값" 쌍(pair)라고 지칭합니다.

키-값 쌍에서 키는 유일해야 하며 키에 매핑된 값은 키를 통해서만 접근할 수 있습니다.
키는 일반 텍스트일 수도 있고 해시 값일 수도 있습니다. 성능상의 이유로 키는 짧을수록 좋습니다.

- 키의 예시
  - 일반 텍스트 키 : "last_logged_in_at"
  - 해시 키 : 253DDEC4

> 키는 왜 짧을수록 좋은가?

키-값 쌍에서 값은 문자열, 리스트, 객체 등 무엇이 오든지 크게 상관하지 않습니다.
대표적으로 아마존 DynamoDB, memcached, Redis가 있습니다.  
우리는 이번 장을 통해 다음 연산을 지원하는 키-값 저장소를 설계해 볼 것입니다.

- put(key, value) : 키-값 쌍을 저장소에 저장한다.
- get(key) : 인자로 주어진 키에 매달린 값을 꺼낸다.

## 문제 이해 및 설계 범위 확정

완벽한 설계란 없습니다. 문제 상황에 따라 읽기 / 쓰기 / 메모리 사용량 사이에 균형을 찾고,
데이터의 일관성 / 가용성 사이에 타협적 결정을 내린 설계를 만든다면 괜찮을 것입니다.
이번 장에서는 아래의 특성을 가지는 키-값 저장소를 설계해 볼 것입니다.

- 키-값 쌍의 크기는 10KB 이하이다.
- 큰 데이터를 저장할 수 있어야 한다.
- 높은 가용성을 제공해야 한다. 장애가 있더라도 빠른 응답을 해야한다.
- 높은 규모 확장성을 제공해야 한다. 트래픽 양에 따라 자동적인 서버 증설/삭제가 이루어져야 한다.
- 데이터 일관성 수준은 조정이 가능해야 한다.
- 응답 지연시간이 짧아야 한다.

## 단일 서버 키-값 저장소
한 대 서버만 사용하는 키-값 저장소를 설계하는 것은 쉽습니다.
가장 직관적인 방법은 해시 테이블에 키-값 쌍 전부를 저장하는 것입니다.
빠른 속도를 보장하긴 하지만 모든 데이터를 메모리에 두는 것이 불가능한 경우도 있다는 단점이 있습니다. 문제를 해결하기 위한 방법은 다음과 같습니다.

- 데이터 압축(compression)
- 자주 쓰는 데이터만 메모리에 두고 나머지는 디스크에 저장

하지만 서버 한 대의 한계는 금방 찾아오게 됩니다. 많은 데이터를 저장하기 위해선 **분산**이 필요합니다.

## 분산 키-값 저장소
분산 키-값 저장소는 분산 해시 테이블이라고도 불립니다. 키-값 쌍을 여러 서버에 분산시키는 탓입니다.
분산 시스템을 설계할 때는 CAP 정리를 이해하고 있어야 합니다.

### CAP 정리
**데이터 일관성(Consistency)**, **가용성(availability)**, **파티션 감내(Partition tolerance)** 라는 3가지 요구사항을 동시에
만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리입니다.

- 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 봐야 한다.
- 가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
- 파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야 한다.

CAP 정리는 2가지를 충족하면 나머지 1가지를 희생되어야 하는 것을 의미합니다.

![Image](https://github.com/user-attachments/assets/0697f00f-9a8a-425c-b8dd-e2e6b4cee8d5)

시스템은 지원하는 요구사항에 따라 CP 시스템, AP 시스템, CA 시스템이라고 불립니다.
다만 통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 감내를 지원해야 합니다.
그러므로 CA 시스템은 존재 하지 않습니다.

### 구체적 사례
분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관됩니다. 세 대의 복제(replica) 노드 n1, n2, n3에 데이터를 복제하여
보관하는 상황을 가정해보겠습니다.

#### 이상적 사례

![Image](https://github.com/user-attachments/assets/1d1bcc69-ff32-42c3-a116-6dbe5c844195)

이상적 환경이라면 네트워크가 파티션되는 상황을 절대 일어나지 않으므로 n1에 데이터가 기록되면 자동적으로 n2와 n3에 복제됩니다.
데이터 일관성과 가용성도 만족합니다.


#### 실세계의 분산 시스템

![Image](https://github.com/user-attachments/assets/2eeb25eb-2a7b-442e-8ca2-b6b9e3eef923)

분산 시스템은 파티션 문제를 피할 수 없습니다. 파티션 문제가 발생하면 일관성과 가용성 사이에서 하나를 선택해야 합니다.
그림은 n3에 장애가 생겨 나머지 노드와 통신할 수 없는 상황을 나타냅니다.
만약 n3에 기록이 되었다면 n1과 n2데이터가 전달되지 않아 오래된 사본을 가진 채로 있게 됩니다.

- 일관성을 선택하는 경우
  - 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 n1과 n2에 대해 쓰기 연산을 중단시킵니다.
    보통 은행권 시스템은 데이터 일관성을 견고하게 지키려 합니다. 네트워크 파티션때문에 문제가 발생한 경우
    상황이 해결될 때 까지 오류를 반환합니다.
- 가용성을 선택하는 경우
  - 오래된 데이터를 반환할 위험이 있더라도, 계속 읽기 연산을 허용합니다. n1과 n2또한 쓰기 연산이 계속될 것이고
    파티션 문제가 해결된 후 데이터를 n3에 전송할 것입니다.

따라서 일관성과 가용성 중 어떤 것을 선택할 지 면접관과 상의하고 결정하도록 합니다.

### 시스템 컴포넌트
다음은 키-값 저장소 구현에 사용될 핵심 컴포넌트 및 기술입니다. 
- 데이터 파티션
- 데이터 다중화(replication)
- 일관성(consistency)
- 일관성 불일치 해소(inconsistency resolution)
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로(write path)
- 읽기 경로(read path)

다이나모, 카산드라, 빅테이블의 사례를 참고하여 어떤 컴포넌트인지 살펴봅니다.

#### 데이터 파티션
대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 모두 때려넣는 것은 불가능합니다.

> 잔지바는 뭐임 그럼?

가장 단순한 해결책은 데이터를 작은 파티션으로 분할한 다음 여러 서버에 저장하는 것입니다.
이 때 중요하게 생각할 두 가지 문제가 있습니다.
- 데이터를 여러 서버에 고르게 분산할 수 있는가?
- 노드가 추가되거나 삭제될 때 이동을 최소화할 수 있는가?

5장에서 살펴봤던 안정 해시를 이용하면 구현이 가능하니 장점만 간단히 짚고 넘어가겠습니다.
- 규모 확장 자동화가 가능하다.
- 다양성 : 각 서버의 용량에 맞게 가상노드의 수를 조정할 수 있다.

#### 데이터 다중화
높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있습니다.
N은 튜닝 가능한 값입니다. N개 서버를 선정하는 방법은 다음과 같습니다.
- 어떤 키를 해시 링 위에 배치한다.
- 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.

가상 노드를 사용한다면 위와 같이 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있습니다.
이 문제를 피하려면 노드를 선택할 때 같은 물리 서버를 중복 선택하지 않도록 해야 합니다.  
같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연재해 등 문제를 동시에 겪을 가능성이 있습니다.
따라서 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결합니다.

#### 데이터 일관성
여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 합니다.
정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있습니다.

> 정족수 합의 프로토콜(Quorum Consensus) : 분산 시스템에서 데이터 일관성을 유지하기 위한 합의 프로토콜입니다.
> 여러 노드에 데이터가 복제되어 있을 때 읽기/쓰기 요청을 특정 수 이상의 노드로 제한함으로써 충돌없이 정합성을 유지합니다.

관계된 정의부터 살펴보겠습니다.
- N : 사본 개수
- W : 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답 필요
- R : 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답 필요

N이 3인 경우에 대한 예제의 상황은 다음과 같습니다.

![Image](https://github.com/user-attachments/assets/64717fa5-0c4c-4baf-94c1-e595710613fb)

W = 1인 경우는 한 대에 서버에만 기록된다는 뜻이 아닙니다. 중재자가 최소 한 대의 서버로부터 쓰기 성공 응답을 받았다는 의미입니다.
따라서 W의 수가 충족되면 나머지 노드로부터의 응답은 기다릴 필요가 없습니다.  
W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점(trade-off)을 찾는 과정입니다.
W나 R의 값이 크다면 중재자는 다수의 응답이 가장 느린 서버의 응답이 올 때까지 기다려야 하고
W나 R의 값이 작다면 일관성이 깨져있을 확률이 비교적 높을 것입니다.

W + R > N인 경우 강한 일관성이 보장됩니다. 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹칠 것이기 때문입니다.
다음은 W, R, N 값을 결정할 때 도움이 되는 가이드입니다.

### 참고문헌

[PACELC 이론](https://shinbe.tistory.com/entry/CAP%EC%9D%B4%EB%A1%A0%EC%9D%98-%ED%95%9C%EA%B3%84%EC%99%80-PACELC-%EC%9D%B4%EB%A1%A0-%E2%91%A0)

[Quorum 위키피디아](https://en.wikipedia.org/wiki/Quorum_(distributed_computing))

[정족수와 합의](https://krapi0314.tistory.com/75)

> 📌 **주의사항**
> 
> 
> 이 글은 『가상의 사례로 배우는 대규모 시스템 설계』를 참고하여, **운영 경험이 거의 없는 학습자**로서 내용을 정리한 문서입니다.
> 
> **학습 목적**으로 작성되었으니, 실전 환경과는 다를 수 있음을 감안해주시기 바랍니다.
> 
> 잘못된 부분은 언제든 피드백 부탁드립니다!
> 

<aside>

시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이다.

</aside>

1. 웹 계층은 무상태 계층으로

2. 모든 계층에 다중화 도입

3. 가능한 한 많은 데이터를 캐시할 것

4. 여러 데이터 센터를 지원할 것

5. 정적 콘텐츠는 CDN을 통해 서비스할 것

6. 데이터 계층은 샤딩을 통해 그 규모를 확장할 것

7. 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

---

# **1. 시스템 구조의 단계별 확장 흐름**

> 1명의 사용자를 지원하는 구조에서 수백만 사용자를 지원하는 구조로 점진적으로 확장하는 과정 이해
> 

## **1.1. 단일 서버**

> 모든 구성 요소(웹 서버, 애플리케이션, DB, 캐시 등)가 **하나의 서버** 인스턴스에 함께 배포되어 동작하는 **가장 단순한 아키텍처**
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/49d4bc92-07d4-47e5-85de-73b3db77e623)

웹 서버, 애플리케이션 서버, 데이터베이스, 캐시까지 — 모든 구성 요소가 한 대의 서버 안에서 동작하는 구조다.

---

### **도입 배경**

서비스 초기에는 사용자도 적고, 일단 기능을 빠르게 구현하는 게 중요할 때다.

**설정과 배포가 쉽고**, **비용이 적게 들며**, **빠르게 만들 수 있기 때문**에 단일 서버가 선택된다.

---

### **동작 방식**

- 모든 구성 요소가 단일 서버에서 동작
- DB, 캐시, 애플리케이션 간 통신이 모두 로컬에서 이뤄짐
- 레이턴시가 거의 없음

---

### **장점**

- **설정과 배포가 쉽다**: 서버 한 대만 설정하면 끝
- **비용이 적게 든다**: EC2 하나로 모든 게 해결
- **빠르다**: 로컬 통신으로 레이턴시 거의 없음
- **빠르게 만들 수 있다**: 해커톤이나 MVP 단계에 적합

→ 요약하면, **“빠르고 싸고 쉽다”**

---

### **단점 / 주의점**

- **확장성의 한계**: EC2 인스턴스를 키우는 데 한계 있음
- **장애 전파**: 하나만 죽어도 전부 멈춘다
- **배포 어려움**: 백엔드 수정 시 프론트까지 같이 재배포 필요
- **트래픽 병목**: 유저가 많아지면 DB, 네트워크가 병목
- **보안 경계가 흐림**: 시스템 간 분리가 없어 보안에 취약

---

### **도입 시점**

- 서비스 초기
- 사용자 적고 빠르게 구현해야 하는 상황
- 해커톤, MVP, 프로토타입 등

## **1.2. 데이터베이스 계층 분리**

> **웹 서버와 데이터베이스를 물리적으로 분리**하여, 각각의 역할을 독립적으로 수행하도록 만든 구조
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/f68c78c6-1592-4a96-bf93-6960d3a77aea)

단일 서버 구조에서는 웹 서버, DB, 캐시가 모두 한 인스턴스 안에서 동작한다.

하지만 사용자가 늘고 트래픽이 증가하면, **가장 먼저 병목이 생기는 곳은 데이터베이스**다.

그래서 **웹 서버와 DB 서버를 분리**하여, 각각 다른 서버에서 동작하도록 하는 구조가 등장한다.

이 구조에서는 웹 서버는 API 요청 처리에만 집중하고, DB 서버는 데이터 읽기/쓰기에만 집중한다.

---

### **도입 배경**

- 사용자 수가 증가하고, 트래픽이 많아지며 **DB에 병목이 발생**
- 단일 서버의 리소스 분산이 문제로 이어짐

---

### **동작 방식**

- 웹 서버와 DB가 **서로 다른 인스턴스**에서 실행됨
- API 서버는 클라이언트 요청을 처리하고
- DB 서버는 **데이터 I/O만 전담**

---

### **장점**

- **리소스 간섭 제거**: 웹 서버와 DB가 서로 CPU·메모리를 뺏지 않음
- **독립적인 확장 가능**: 웹 서버는 수평 확장, DB 서버는 성능 튜닝 또는 복제 가능
- **장애 격리**: 한 쪽 장애가 전체 서비스로 퍼지지 않음
- **보안 강화**: DB 서버를 외부 접근 차단, 네트워크 분리 가능

---

### **단점 / 주의점**

- **설정과 운영 복잡도 증가**: 네트워크, 보안, 배포 등 관리 포인트 증가
- **네트워크 레이턴시 발생**: DB가 로컬이 아니므로 응답 속도 소폭 저하
- **인프라 비용 증가**: 물리적 인스턴스 수 증가

---

### **도입 시점**

- 사용자 수가 늘고, **DB 병목이 명확하게 나타날 때**
- 웹 서버와 DB가 **서로 다른 부하 특성**을 보일 때

---

## **📎 별첨: 관계형 vs 비관계형 데이터베이스**

---

### **관계형 데이터베이스 (RDBMS)**

> 정형 데이터와 복잡한 쿼리에 강함
> 
- **예시**: MySQL, PostgreSQL, Oracle
- **구조**: 행(Row)과 열(Column)로 구성된 테이블
- **특징**:
    - **SQL 기반 쿼리 지원**, JOIN 가능
    - **데이터 정합성 보장 (ACID 트랜잭션)**
    - 스키마 강제 → 데이터 구조 명확

→ 명확한 스키마 + 복잡한 관계/질의가 필요할 때

---

### **비관계형 데이터베이스 (NoSQL)**

> 유연한 구조와 대규모 확장성에 강함
> 
- **예시**: Redis, MongoDB, Cassandra, DynamoDB, Neo4j
- **특징**:
    - 스키마 유연 또는 없음
    - JOIN 대신 데이터 중복 허용
    - **수평 확장**에 강함 (노드 쉽게 추가)

---

### **NoSQL 종류**

| **유형** | **예시** | **사용 시점** |
| --- | --- | --- |
| Key-Value | Redis, DynamoDB | 캐시, 세션, 단순 조회 |
| Document | MongoDB, CouchDB | JSON 구조 데이터, 유동적 스키마 |
| Column | Cassandra, HBase | 대규모 분석, 빠른 읽기/쓰기 |
| Graph | Neo4j | 관계 중심 구조 (SNS 등) |

---

### **NoSQL이 유리한 상황**

- **초고속 응답 필요**: Redis → RAM 기반 저장
- **비정형/유동적인 데이터**: MongoDB → 구조 없이도 저장 가능
- **직렬화만 되면 OK**: JSON ↔︎ 그대로 저장/조회
- **대용량 데이터 분산 저장**: Cassandra → 자동 샤딩, 무중단 운영

## **1.3. 수직적 규모 확장 vs 수평적 규모 확장**

> 시스템이 커지면 성능 확장이 필요하다.
> 
> 
> 이때 선택지는
> 
> - **수직 확장 (Scale Up)**: 더 좋은 서버로 바꾼다 → 구조는 단순하지만 물리적 한계가 명확
> - **수평 확장 (Scale Out)**: 서버 수를 늘린다 → 설계가 복잡해지지만 유연하고 안정적이다

---

### **구조 설명**

- **수직 확장**은 기존 서버의 사양(CPU, RAM 등)을 업그레이드하여 처리 성능을 높이는 방식이다.
- **수평 확장**은 서버를 여러 대로 늘려, 트래픽이나 요청을 분산 처리하는 방식이다.

---

### **도입 배경**

서비스가 성장하고 사용자 수가 늘어나면서 **단일 서버나 단일 DB 구조의 성능 한계**에 도달한다.

이를 해결하기 위해 **성능 확장**이 필요해진다.

---

### **동작 방식**

- **수직 확장**: 하나의 인스턴스 성능을 높여 더 많은 요청을 처리
- **수평 확장**: 여러 인스턴스를 두고, 트래픽을 나눠 처리

---

### **장점**

### **⬆️ 수직 확장**

- 구조가 단순하여 유지보수와 배포가 쉽다
- 빠르게 대응할 수 있는 방법 (스펙 업그레이드만 하면 됨)

### **➡️ 수평 확장**

- 유저 수 증가에 유연하게 대응 가능 (확장성 우수)
- 일부 서버가 죽어도 전체 서비스는 유지됨 (고가용성 확보)

---

### **단점 / 주의점**

### **⬆️ 수직 확장**

- 인스턴스 스펙에 물리적 한계가 존재
- 하나의 서버에 모든 기능이 몰리므로 장애 발생 시 전체 서비스 중단
- 고가용성 구성, 자동 복구에 불리

### **➡️ 수평 확장**

- 아키텍처가 복잡해짐 (서버 간 데이터 동기화, 세션 공유 등)
- 로드 밸런서, 헬스 체크, 세션 클러스터링 등 **추가 설계 필요**

---

### **도입 시점**

- ⬆️ **수직 확장**:
    - 유저 수가 적은 초기 서비스
    - 빠르게 프로토타입을 만들어야 할 때
    - “당장 돌아가기만 하면 되는” 상황
- ➡️ **수평 확장**:
    - 트래픽 급증이 예상되는 서비스
    - 장애 대응과 무중단 서비스가 중요한 환경
    - 안정성과 유연한 확장이 중요한 운영 단계

---

### **로드 밸런서 - 수평 확장 시 웹 계층 문제 해결**

> 여러 대의 웹 서버 앞에 위치해, **들어오는 트래픽을 분산 처리**하는 컴포넌트
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/4a8ce493-e94d-4a05-8594-e12110c84dff)

- 사용자는 로드밸런서의 공인 IP(예: 88.88.88.1)로 접속
- 로드밸런서가 요청을 내부의 웹 서버 중 하나로 전달함

---

### **도입 배경**

- 웹 서버 한 대로는 트래픽을 감당하기 어렵기 때문에
- **서버 수를 늘리고 트래픽을 분산**해 처리량을 확보할 필요가 생김

---

### **동작 방식**

- 클라이언트의 요청을 로드밸런서가 수신
- 내부 상태를 체크한 뒤, 가용한 서버에 요청 전달
- 서버 응답은 다시 클라이언트에게 전달됨

---

### **장점**

- **장애 자동 복구(Failover)**: 서버가 죽으면 다른 서버로 자동 분산
- **확장 유연성**: 서버 수만 늘리면 바로 대응 가능
- **서비스 가용성 확보**: SPOF 제거, 중단 없는 서비스 운영

---

### **단점 / 주의점**

- **세션 관리 필요**: 로그인 유지 위해 세션 공유 필요 (Sticky Session, Redis 등)
- **로드밸런서 자체 이중화 필요**: 로드밸런서도 장애날 수 있음
- **헬스 체크 필수**: 죽거나 느린 서버를 제외해야 함
- **분산 전략 고려**: Round-robin, 가중치 등 환경에 맞게 설정

---

### **도입 시점**

- 트래픽이 늘고, **서버 한 대로는 한계가 명확할 때**
- 무중단 서비스를 위한 고가용성이 필요한 시점

---

### **데이터베이스 다중화 - 수평 확장 시 데이터 계층 문제 해결**

> 데이터 읽기 요청을 **여러 DB 서버로 분산**해 성능과 안정성을 확보하는 구조
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/2ae42b49-ec2b-4f95-87be-6a111bbb3cdb)

- **주 DB (Master)**: 모든 쓰기 연산 처리
- **부 DB (Slaves)**: 주 DB의 사본으로, 읽기 전용 동작

---

### **도입 배경**

- DB에 읽기 트래픽이 몰려 병목이 생기기 시작할 때
- **읽기 연산을 분산**하여 트래픽을 줄이고 안정성을 확보하려는 필요성

---

### **동작 방식**

- 클라이언트 요청 중 쓰기는 Master로, 읽기는 Slave로 전달
- Slave는 주기적으로 Master로부터 데이터를 복제

---

### **장점**

- **성능 향상:** 읽기 트래픽이 여러 부 DB로 분산되어 처리량 증가
- **가용성(Availability):** 주 DB나 부 DB에 장애가 생겨도 다른 서버로 요청을 넘겨 **서비스 지속 가능**
- **안정성(Reliability):** 여러 지역에 DB를 분산 배치하면 **자연 재해 등에도 데이터 보존 가능**

---

### **단점 / 주의점**

- **쓰기 병목은 여전히 존재**
    
    쓰기 연산은 주 DB에만 가능 → 쓰기 트래픽이 많을 경우 별도 대안 필요
    
- **데이터 동기화 지연**
    
    부 DB는 주 DB로부터 데이터를 복제받기 때문에 항상 최신 상태가 아닐 수 있음
    
- **운영 복잡도 증가**
    
    장애 복구, 새로운 부 DB 설정, 복제 지연 감지 등 운영상 고려할 요소가 많아짐
    

---

### **도입 시점**

- **읽기 트래픽이 많은 서비스**
- 장애 복구 시나리오가 필요할 때
- 글로벌 서비스 운영 등 **지리적 분산**이 필요할 때

---

### **장애 시 대응**

- **Slave 장애**: 다른 Slave로 자동 분산, 새 Slave 추가 복제 시작
- **Master 장애**: Slave를 Master로 승격, 다른 Slave는 새 Master에서 복제 시작
    
    → 복제 지연 시 데이터 누락 발생 가능, 복구 작업 필요
    
    ![로드밸런서, 데이터베이스 다중화 도입 후](https://github.com/user-attachments/assets/02ce83c6-3984-4eff-8938-79ea089186a7)
    
    로드밸런서, 데이터베이스 다중화 도입 후
    

---

### 내 생각

- 리플리케이션이랑 클러스터링 다 까먹음 .. (+ CQRS)

## **1.4. 캐시 도입**

> 자주 참조되거나 계산 비용이 큰 데이터를 메모리에 저장해
**응답 속도를 높이고 DB 부하를 줄이는 계층 구조**
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/b396bfdb-7271-4a39-8e42-83df79517a4d)

- DB보다 빠른 저장소(메모리)에 데이터를 임시 저장
- 요청 시 캐시에 있으면 → **즉시 응답**
- 없으면 DB에서 읽고 → **캐시에 저장한 후 응답**
- 이를 **Read-Through Caching 전략**이라고 함

---

### **도입 배경**

- 웹 페이지를 새로고침할 때마다 DB 호출 → **비효율**
- 호출이 많아질수록 애플리케이션 성능 저하
- 이런 문제를 완화하기 위한 가장 단순한 접근법이 캐시

---

### **동작 방식**

- 클라이언트 요청이 들어오면
    
    → 캐시에 해당 데이터가 있는지 먼저 확인
    
    → 있으면 응답, 없으면 DB 조회 후 캐시에 저장
    

---

### **장점**

- **속도 개선**: DB보다 수십~수백 배 빠른 응답
- **DB 부하 감소**: 캐시 적중률이 높을수록 DB 호출 횟수 급감
- **독립 확장 가능**: 캐시 계층만 수평 확장 가능

---

### **단점 / 주의점**

- **휘발성 저장소**: 재시작 시 데이터 유실
- **일관성 이슈**: DB와 캐시 데이터 불일치 가능
- **운영 복잡성**: TTL 설정, 장애 복구, eviction 정책 필요
- **SPOF 위험**: Redis 하나만 두면 장애 발생 시 전체 영향

---

### **📌 어떤 상황에 캐싱?**

- Create/Update/Delete는 드물고, **Read가 많은 경우**
- *읽기는 많고, 자주 안 바뀌는 데이터*에 적합

---

### **📌 어떤 데이터를 캐싱?**

- 중요한 데이터는 **DB 저장이 우선**
- 캐시는 **보조 저장소**로 사용

---

### **📌 만료(Expire) 정책**

- 너무 짧으면 → miss 자주 발생 → **DB 부하 증가**
- 너무 길면 → 오래된 정보 노출 → **신선도 저하**

---

### **📌 일관성 유지**

- **DB와 캐시가 따로 갱신되면 불일치 가능성**
    
    → 예: DB는 바뀌었는데 캐시는 이전 값 그대로
    
- **단일 트랜잭션 안에서 DB+캐시 처리**가 아니면 깨질 수 있음
- 다지역 시스템에서는 **동기화 더욱 복잡**
    
    → *"캐시=정답"이 아님. 일관성이 중요하면 TTL을 짧게 하거나 캐시 자체를 쓰지 않기도 함*
    

---

### **📌 장애 발생 시**

- **Redis 하나만 두면 SPOF(Single Point of Failure)**
    
    → 죽으면 전체 서비스 지연 or 장애 발생
    
- → **Redis Sentinel, Cluster 구성** 또는 장애 대비 fallback 로직 필요

---

### **📌 캐시 메모리 크기 설정**

- 작으면 자주 밀려나서 적중률 낮아짐
- 너무 크면 시스템 전체 메모리 압박
- → 일반적으로 **전체 메모리의 50~70%** 사이에서 튜닝

---

### **📌 데이터 방출(Eviction)**

- 캐시가 꽉 차면 → 오래된 데이터 제거
- 방출 정책 선택 필요
    - LRU: 가장 오래 안 쓴 것 제거
    - LFU: 가장 덜 사용된 것 제거
    - FIFO: 먼저 들어온 것부터 제거

---

### **도입 시점**

- Read가 많은 정적/반정적 데이터가 존재할 때
- DB 부하가 높고, 응답 지연이 문제가 될 때
- 빠른 응답이 중요한 기능

---

### 내 생각

- 캐시는 빠름을 싸게 얻는 방법인 것 같다. 물론 일관성이나 만료 같은 고려사항은 있지만, 실제로는 이론보다 운영하면서 통계를 보고 결정하는 게 중요할 것 같다.
- 잊어버린 캐싱 전략도 한 번 다시 보도록 하자.

## **1.5. 콘텐츠 전송 네트워크(CDN)**

> 정적 콘텐츠(이미지, JS, CSS 등)를 지리적으로 가까운 서버에서 전송해
로딩 속도를 빠르게 하고, 원본 서버의 부하를 줄여주는 시스템
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/f4b0a2c2-8e07-4162-a78c-b65363c6efbd)

- 사용자가 CDN URL로 정적 리소스 요청
- CDN에 캐시가 없으면 원본(origin)에서 받아 저장
- 다음 사용자부터는 CDN이 직접 응답

---

### **도입 배경**

- 사용자 위치와 서버 간 거리 차이가 로딩 속도에 큰 영향
- 자주 바뀌지 않는 리소스를 매번 원본 서버에서 받는 건 비효율
- → CDN으로 빠르고 안정적인 사용자 경험 제공

---

### **동작 방식**

1. 사용자가 CDN 주소로 정적 파일 요청
2. CDN 서버에 캐시가 없으면 → 원본 서버에서 받아와 저장
3. 다음 요청부터는 → CDN 서버가 직접 응답

---

### **장점**

- **로딩 속도 개선**: 사용자와 가까운 서버가 응답
- **원본 서버 부하 감소**: 반복 요청은 CDN이 처리
- **자동 확장 가능**: 글로벌 분산 네트워크 기반으로 대규모 트래픽 대응 용이

---

### **단점 / 주의점**

| **항목** | **설명** |
| --- | --- |
| **비용** | 유료 서비스가 많고, 전송량 기반 요금 발생 |
| **TTL 설정** | 너무 짧으면 원본 접근 증가, 너무 길면 오래된 콘텐츠 노출 |
| **무효화 전략** | API 호출 또는 버전 쿼리(?v=2)로 캐시 무효화 |
| **CDN 장애 시** | 백업 플랜 필요, 원본 서버로 fallback 설정 고려 |
| **동적 콘텐츠 미지원** | HTML처럼 사용자별 응답이 다른 콘텐츠는 CDN 부적합 |

---

### **도입 시점**

- 이미지, JS, CSS 등 **정적 자산 요청이 많을 때**
- 글로벌 사용자 대상 서비스
- 페이지 로딩 속도가 중요한 환경 (예: 쇼핑몰, 뉴스, 블로그 등)

---

### 내 생각

- 정적 콘텐츠는 Nginx로도 처리 가능한데, 글로벌 트래픽을 고려해야 할 시점이 오면 CDN을 쓰게 되는 건가?
- 실무에서는 어떤 기준으로 Nginx vs CDN을 선택할지 궁금함
    
    → [CloudFront vs Nginx 비교 링크](https://velog.io/@kimhalin/CloudFront-Nginx-VS-Nginx-%EB%AD%90%EA%B0%80-%EB%8D%94-%EB%82%98%EC%9D%84%EA%B9%8C)
    

---

![CDN과 캐시가 추가된 설계](https://github.com/user-attachments/assets/904fbcbf-d400-4051-a600-a558504f9e43)

CDN과 캐시가 추가된 설계

## **1.6. 무상태 웹 계층 (Stateless Web Layer)**

> 사용자 상태(세션 등)를 서버가 아닌 외부 저장소로 분리해, 모든 웹 서버가 동일한 요청을 처리할 수 있도록 만든 구조.
> 
> 
> 수평 확장에 유리하고, 서버 장애 시 복구가 쉬운 **확장성과 안정성을 위한 기본 아키텍처**.
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/02b31869-fcae-400e-b3f0-ec7f02605a39)

- 사용자 세션, 프로필 등 상태 정보는 **웹 서버가 아닌 외부 저장소에 저장**
- 어떤 서버가 요청을 받아도 필요한 상태는 **공유 저장소에서 가져와 처리**
- → 모든 웹 서버가 동일하게 동작할 수 있음

---

### **도입 배경**

![Image](https://github.com/user-attachments/assets/a2597750-e1d9-4e94-b597-d0a9b3421b20)

- 상태(state)가 서버에 있으면, 로드밸런싱이 어려워짐
- 서버 장애 시 세션도 함께 사라지는 문제가 발생
- 같은 사용자의 요청은 같은 서버로 보내야 하는 제약 → **Sticky Session** 필요 → 관리 복잡도 증가

---

### **동작 방식**

![Image](https://github.com/user-attachments/assets/2816560c-660b-465e-9749-9332e18d4229)

- 모든 서버는 **상태를 저장하지 않음**
- 세션, 사용자 정보 등은 **Redis, DB, NoSQL 등 외부 저장소에 저장**
- 서버는 요청 시마다 외부에서 상태 데이터를 조회해 응답

---

### **장점**

- **수평 확장 용이**: 서버를 쉽게 추가/제거 가능
- **오토 스케일링 가능**: 트래픽 증가 시 자동 확장 구조 구현 가능
- **장애 복구 용이**: 특정 서버 장애 시 다른 서버가 그대로 처리 가능

---

### **단점 / 주의점**

- **공유 저장소가 병목 지점이 될 수 있음**: Redis 등에 부하 집중 가능
- **네트워크 지연**: 상태 데이터를 외부에서 불러오기 때문에 로컬보다 느림
- **데이터 일관성 문제**: 분산 환경에서 상태 동기화 필요

---

### **도입 시점**

- 수평 확장이 필요해지는 시점
- 서버 간 상태 공유나 세션 유지가 문제 되는 시점
- 로드밸런서 뒤에 여러 웹 서버가 붙는 구조일 때

## **1.7. 다중 데이터 센터 구성**

> 전 세계 사용자에게 빠르고 안정적인 서비스를 제공하기 위해, 지리적으로 분산된 여러 데이터센터를 두고, 사용자의 위치에 따라 **가장 가까운 곳으로 요청을 라우팅(GeoDNS)**하며, 장애 시에는 자동으로 다른 센터로 **트래픽 우회(failover)**하는 구조.
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/4d363216-cde7-429c-8c56-3049b95d7605)

- 각 지역에 데이터 센터를 여러 개 두고
- 사용자의 물리적 위치에 따라 **가장 가까운 데이터 센터로 요청을 분산**
- 특정 데이터 센터에 장애가 생기면, **다른 센터로 자동 우회**

---

### **도입 배경**

- 전 세계 사용자 대상 서비스에서 **지연 시간(Latency)**을 줄이기 위함
- 한 곳에 모든 트래픽이 집중되면 **성능 저하 + 장애 위험** 발생
- → **지리적 분산**과 **장애 대비 설계**가 필수

---

### **동작 방식**

- **GeoDNS**: DNS 수준에서 사용자의 위치 기반으로 DC 결정
- **데이터 다중화**: 중요한 데이터는 각 센터에 동기화하여 저장
- **Failover**: 장애 발생 시 트래픽을 자동으로 다른 센터로 전환

---

### **장점**

- **지연 시간 감소**: 사용자와 가까운 DC에서 응답
- **고가용성**: 한 DC가 죽어도 서비스 지속 가능
- **트래픽 분산**: 특정 지역 과부하를 방지

---

### **단점 / 주의점**

- **데이터 동기화 어려움**: 멀티 센터 간 실시간 동기화는 까다로움
- **구성 복잡도**: 인프라, 배포, 모니터링 모두 복잡해짐
- **비용 증가**: 여러 센터 운영 시 인프라 비용 상승

---

### **도입 시점**

- 글로벌 트래픽이 많거나, **특정 지역 사용자 비중이 높을 때**
- 장애 복원력과 고가용성이 **핵심 요구사항일 때**
- 수평 확장을 넘어서 **글로벌 분산 구조가 필요할 때**

---

### **기술적 과제**

- **트래픽 우회 전략**
    - GeoDNS 등을 활용해 사용자를 적절한 DC로 유도
- **데이터 동기화**
    - 각 센터가 독립된 DB를 가지면 데이터 유실 가능성 존재
    - 해결책: 데이터를 **여러 DC에 다중화 저장**
- **테스트 & 배포 자동화**
    - 코드와 설정을 모든 DC에 **동일하게 배포**해야 함
    - → CI/CD 도입 필요 (예: 넷플릭스 구조 참고)

---

### 내 생각

- 취업하지 않는 한 사용 안 할 듯?

## **1.8. 메시지 큐 도입**

> 서비스 간 연결을 느슨하게 만들어, **비동기 작업 처리와 유연한 확장성**을 가능하게 하는 핵심 아키텍처 컴포넌트
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/a011e431-2367-4bd3-a782-5e91aa7d6a17)

- **Producer (생산자)**: 메시지를 생성하여 큐에 넣는 역할 (예: 웹 서버)
- **Queue**: 메시지를 일시 저장, 비동기 버퍼 역할
- **Consumer (소비자)**: 큐에서 메시지를 꺼내 처리 (예: 워커 서버)

---

### **도입 배경**

- 모든 요청을 **즉시 동기 처리**하면, 하나만 느려도 전체가 느려짐
- **생산자-소비자 간 독립성 확보**가 필요해짐
- 트래픽 폭증, 비동기 작업, 장애 상황에 **유연하게 대응**할 수 있어야 함

---

### **동작 방식**

- 웹 서버(Producer)는 작업 요청을 큐에 넣고, 사용자에겐 바로 응답
- 큐는 메시지를 저장
- 워커 서버(Consumer)가 큐에서 메시지를 꺼내 작업을 수행

---

### **장점**

- **비동기 처리 가능**: 시간이 오래 걸리는 작업을 나중에 처리
- **성능 분산**: 생산자-소비자의 속도를 독립적으로 유지 가능
- **트래픽 완충(Buffering)**: 요청을 일단 큐에 쌓아 처리량 조절
- **유연한 확장성**: 워커 수 조절로 유입량에 따라 대응 가능
- **서비스 분리**: 각 컴포넌트 간 결합도 낮아 장애 전파 억제

---

### **단점 / 주의점**

| **문제** | **설명** |
| --- | --- |
| **시스템 복잡도 증가** | 아키텍처가 복잡해짐, 배포/테스트/모니터링 부담 |
| **운영 난이도** | 큐가 쌓이면 병목 위치 파악 어려움 |
| **중복 처리 가능성** | 메시지 중복 소비 발생 → **idempotency 설계 필수** |
| **처리 지연** | 큐가 길어지면 응답/작업 처리까지 대기 시간 증가 |

---

### **도입 시점**

- **비동기 작업 처리 필요**: 예) 이미지 변환, 이메일 발송 등
- **유저 응답 속도 개선 필요**: 작업은 나중에, 응답은 먼저
- **트래픽 급증에 대비**: 큐가 일시적인 버퍼 역할 수행
- **시스템 간 독립성 강화 필요**: 장애 전파를 최소화해야 할 때
- **컴포넌트별 확장이 필요할 때**

---

### **사용 예시**

**사진 보정 서비스**

- 사용자가 사진 업로드
- 웹 서버는 보정 Job을 메시지 큐에 넣고, “접수 완료” 응답
- 워커 서버가 큐에서 Job을 꺼내 crop, blur 등 비동기 처리
- 트래픽 상황에 따라 워커 수 유동 조절 가능

---

### 내 생각

- 메시지 큐 누락이나 재시도 어떻게 관리하는지 다 까먹음 ..

## **1.9. 운영 도구 도입 (로그, 메트릭, 자동화)**

> 시스템이 커지면 “기능 개발”보다 “운영 효율화”가 훨씬 중요해진다.
로그, 메트릭, 자동화는 그 운영을 가능하게 해주는 **기초 체력 장비**다.
> 

---

## **1.9.1. 로그 (Logging)**

> 무슨 일이 벌어졌는지 추적하는 도구
> 

---

### **구조 설명**

- 애플리케이션, 시스템, 보안 등 다양한 로그를 **중앙 수집 시스템**으로 모아서 관리
- 대표 도구: ELK Stack (Elasticsearch, Logstash, Kibana), Datadog, CloudWatch 등

---

### **도입 배경**

- 서버가 한두 대일 때는 콘솔 로그로도 충분
- 서버 수가 늘고 장애가 복잡해지면, **로그가 유일한 단서가 된다**

---

### **동작 방식**

- 각 서버에서 발생한 로그를 수집기(agent)가 수집
- 중앙 저장소에 적재 → 쿼리 및 시각화 도구로 분석

---

### **장점**

- 에러 발생 위치 추적 가능 (예: 스택 트레이스)
- 사용자 요청 흐름 파악
- 이상 징후 탐지 및 보안 감시

---

### **단점 / 주의점**

- 로그가 많아질수록 저장 비용 및 성능 저하 우려
- 개인정보가 로그에 담기면 보안 위험 발생 가능

---

### **도입 시점**

- 서버가 여러 대 이상으로 증가할 때
- 장애나 에러 원인 분석이 어려워졌을 때

---

## **1.9.2. 메트릭 (Metrics)**

> 현재 시스템 상태를 한눈에 파악할 수 있는 숫자 대시보드
> 

---

### **구조 설명**

- 시스템 상태를 나타내는 **숫자형 지표(CPU 사용률, DB 쿼리 시간 등)**를 수집 및 시각화
- 대표 도구: Prometheus, Grafana, Datadog 등

---

### **도입 배경**

- 로그는 과거 분석용이고,
- 메트릭은 **실시간 시스템 상태 모니터링**을 위한 도구

---

### **동작 방식**

- 에이전트 또는 애플리케이션이 메트릭 데이터를 수집
- 메트릭 서버로 전송 → 대시보드에서 시각화 및 알림 설정

---

### **장점**

- 시스템 자원 상태 실시간 파악 (CPU, 메모리, 디스크 등)
- 지연 시간, 캐시 적중률 등 운영 품질 확인
- 비즈니스 지표(Daily Active User, 구매율 등) 모니터링 가능

---

### **단점 / 주의점**

- **지표가 많을수록** 오히려 분석이 어려워질 수 있음
- 알람 설정 잘못하면 **알람 피로(Alarm Fatigue)** 유발

---

### **도입 시점**

- 사용자 수나 트래픽이 일정 수준 이상일 때
- 시스템 상태를 미리 감지하고 대응하고 싶을 때

---

## **1.9.3. 자동화 (Automation)**

> 반복적인 작업을 기계에게 넘겨서 개발자는 더 중요한 일에 집중하게 만든다
> 

---

### **구조 설명**

- 코드 변경부터 테스트, 빌드, 배포까지 **자동화된 파이프라인**으로 처리
- 대표 도구: GitHub Actions, Jenkins, GitLab CI/CD 등

---

### **도입 배경**

- 초기에는 수동 배포 가능하지만,
- 팀이 커지고 릴리스 주기가 빨라지면 **수동 작업은 병목이 됨**

---

### **동작 방식**

- 커밋 발생 → 자동 테스트 및 빌드 → 자동 배포
- 환경별 스크립트, 인프라 설정까지 코드로 관리 (IaC 포함)

---

### **장점**

- 배포 속도 향상, 실수 방지
- 코드 품질 자동 검증
- 릴리스 프로세스 표준화 가능

---

### **단점 / 주의점**

- 자동화가 잘못 설정되면 실수도 자동으로 전파됨
- **롤백, 알림 체계 함께 구성**되어야 안정성 확보 가능

---

### **도입 시점**

- 릴리스 주기가 짧아졌을 때 (ex. 하루에도 수차례 배포)
- 여러 명이 동시에 작업하는 팀에서 협업이 잦을 때

---

![**메시지 큐 + 운영 도구들을 반영한 실제 구조**](https://github.com/user-attachments/assets/bd2c12c9-00bf-466d-ab75-adc1b8e87b28)

**메시지 큐 + 운영 도구들을 반영한 실제 구조**

## **1.10. 데이터베이스의 규모 확장**

> 수직 확장은 “빠른 처방”, 수평 확장은 “장기적 해결책”이다.
제대로 확장하려면 샤딩 키부터 전략적으로 설계해야 한다.
> 

---

### **수직 확장 (Vertical Scaling / Scale-Up)**

> 기존 DB 인스턴스를 **더 좋은 사양(CPU, RAM 등)**으로 교체하여 성능을 높이는 방식
> 

---

### **구조 설명**

- DB 구조는 그대로 유지한 채, 인스턴스의 스펙(CPU, 메모리, 디스크 등)을 업그레이드
- 예: AWS RDS 인스턴스를 m5.large → r6i.24xlarge로 교체

---

### **도입 배경**

- 초기 서비스에서는 구조 변경 없이 성능을 개선하고 싶을 때
- 트래픽은 많지 않지만, 쿼리 처리 속도나 리소스가 부족할 때

---

### **동작 방식**

- 같은 논리 DB에 대해 더 강력한 하드웨어에서 실행
- 데이터 구조나 샤딩 불필요 → 개발 및 운영 부담 적음

---

### **장점**

- 구조 변경 없이 바로 대응 가능
- 설정 간단, 유지보수 쉬움
- 개발 부담 거의 없음

---

### **단점 / 주의점**

- 물리적 한계 존재 (더 이상 스펙 업이 불가능한 시점 존재)
- 장애 발생 시 전체 시스템 정지 (SPOF)
- 고성능 장비일수록 비용 폭등

---

### **도입 시점**

- 구조를 바꾸기 어려운 초기 서비스
- 빠르게 응답 개선이 필요한 상황
- 인프라 변경 없이 버티고 싶은 경우

---

## **수평 확장 (Horizontal Scaling / Scale-Out)**

> 데이터를 **여러 DB 인스턴스에 분산 저장**하는 구조로, **샤딩**이 핵심 개념
> 

---

### **구조 설명**

![Image](https://github.com/user-attachments/assets/d3bf40f1-5b58-446d-9872-cf20e346e86e)

![Image](https://github.com/user-attachments/assets/a560de90-5b1c-4c4f-b0ae-7b73418c4d5a)

- user_id 같은 **샤딩 키**를 기준으로 데이터를 여러 DB(Shard)에 나눠 저장
- 각 샤드는 동일한 스키마를 갖지만 데이터는 겹치지 않음

---

### **도입 배경**

- 데이터 양이나 트래픽이 폭증해서 단일 DB 인스턴스로 감당 불가능한 경우
- 더 이상 수직 확장으로는 한계에 부딪혔을 때

---

### **동작 방식**

- 각 샤드는 전체 데이터의 일부만 저장
- 애플리케이션이 샤딩 키를 기준으로 요청을 적절한 DB로 라우팅
- 읽기/쓰기 모두 여러 인스턴스로 분산

---

### **장점**

- 이론적으로 무한 확장 가능
- 특정 샤드 장애 발생 시 전체 서비스가 멈추지 않음
- 데이터나 요청이 분산되므로 성능 부담 완화

---

### **단점 / 주의점**

### **재샤딩 (Resharding)**

- 샤드 간 불균형이 생겼을 때 다시 나눠야 함
- 기존 데이터를 이동해야 하므로 서비스 중단 위험 있음
    
    → **Consistent Hashing**으로 리스크 줄이기도 함
    

### **Hotspot / 유명인사 문제**

- 특정 유저 트래픽이 과도해 한 샤드만 과부하
    
    → 해당 유저를 별도 샤드로 분리하거나 더 작게 쪼갬
    

### **조인/정규화 문제**

- 샤딩 후에는 조인이 어렵기 때문에 **비정규화**로 대응
- 중복 데이터 저장 허용하고 쿼리 성능 우선

---

### **도입 시점**

- 단일 인스턴스로 감당 못할 만큼의 대용량 데이터가 발생했을 때
- 트래픽이 특정 키(user_id 등)에 쏠리는 문제가 발생할 때
- 글로벌 분산 저장소를 구성하고자 할 때

---

### **실전 조합 전략**

- 관계형 DB는 샤딩하여 수평 확장
- 관계가 필요 없는 데이터는 **NoSQL**로 이전
    
    → ex. 로그, 세션, 이벤트 히스토리 등
    

```
DB 쿼리 무겁다 → 샤딩
JOIN 많다 → JOIN 최소화 + 정규화 해제
캐시로 버티기 어렵다 → 샤딩 + 비정규화
특정 유저만 너무 핫하다 → 샤드 쪼개기 or 별도 서버
```

![Image](https://github.com/user-attachments/assets/ce169abd-0b9a-4f45-89aa-738b704e2778)

---

### 내 생각

- 실무에서 진짜 샤딩을 쓸까 ??? 인덱스, 파티셔닝, 레플리케이션, 캐시, NoSQL 같은 방법이 있는데 .. 얼마나 큰걸까
    - 인덱스, 파티셔닝, 샤딩, 레플리케이션 이론 다 까먹음 ㅋㅋ … 이론 및 실무에서 어떻게 사용되는지 학습하는 시간을 가지자 ~
    - https://techblog.woowahan.com/2687/
- 샤딩된 DB에서 여러 샤드에 걸친 통계 쿼리는 어떻게 해야 할까?
    - 샤딩된 운영 DB에선 조인이나 통계 쿼리 돌리기 어려우니까, ETL 파이프라인을 통해 통계 전용 DB로 데이터를 모아 분석한다. 운영은 트랜잭션 위주, 통계는 별도 DB에서!

# **2. 면접 질문 정리**

- 관계형 데이터베이스와 비-관계형 데이터베이스 중에서 고를 때 어떤 기준으로 정해야 하는가?
- 스케일 업과 스케일 아웃에 대해서 설명해 주세요.
- 대규모 애플리케이션을 만들 때 수직적 규모 확장보다 수평적 규모 확장이 더 적절한 이유는 무엇인가요?
- 로드밸런서가 필요한 이유에 대해서 설명해 주세요.
- 데이터베이스를 다중화할 경우 얻을 수 있는 이득은 무엇인가요?
- 캐시를 사용해야하는 이유는 무엇인가요?
- 캐시 계층이 동작하는 과정을 설명해 주세요.
- 캐시를 사용할 때 유의할 점은 무엇인가요?
- CDN을 사용할 때 고려해야 하는 것은 무엇인가요?
- 무상태 아키텍처로 만들어야 하는 이유는 무엇인가요?
- 메세지 큐를 사용해서 얻는 이득은 무엇인가요?
- 데이터베이스의 수직적 확장의 한계는 무엇인가요?
- 샤딩 키를 고를 때 어떤 기준으로 고르는 것이 좋은가요?
- 샤딩을 도입했을 때 생길 수 있는 추가적인 문제는 무엇인가요?

# **3. 회고**

이번 1장을 읽으면서 느낀 건, **운영에서는 구조 설계도 중요하고, 데이터를 기반으로 판단하는 것도 똑같이 중요하다는 점**이다.

책에서는 요구사항이나 병목, 제약 조건 같은 걸 바탕으로 **구조를 설계하는 흐름**을 연습할 수 있다.

반면 실제 서비스에서는 그 구조가 적절한지 **데이터를 보고 판단하고 조정하는 과정**이 더 중요하게 작용할 수 있다.

나처럼 운영 경험이 없는 사람한테는 이 둘을 균형 있게 익히는 게 쉽지 않다.

**크게 설계하면 오버엔지니어링 같고, 그렇다고 아무 고민 없이 만들자니 구조적으로 성장할 기회를 놓치는 기분**이다.

그래서 지금은, **책을 통해 구조적 사고와 설계 방법을 익히고**, **새로 만드는 미니 프로젝트에서는 실제 데이터를 기반으로 의사결정을 해보는 방식**으로 훈련해보려고 한다.

이번에도 단일 서버로 가볍게 시작하겠지만, 문제가 생기면 왜 그런 구조가 필요한지 생각해보고,

필요한 범위 내에서 점진적으로 확장해보는 식으로 진행할 계획이다.

정답을 찾기보다는, **설계와 데이터 사이에서 균형을 잡는 연습을 하는 게 지금 내 상황에서는 가장 현실적인 방향**이라고 느꼈다.

# **4. 참고 링크**

https://github.com/Meet-Coder-Study/book-system-design-interview?tab=readme-ov-file

https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million?utm_campaign=post&utm_medium=web&triedRedirect=true
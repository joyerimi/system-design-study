## 들어가며 
지금까지 단일 서버에 대한 개발만을 고려하고 개발했다. 그러다 보니, 규모가 점점 커졌을 때에는 어떤 아키텍처를 적용해서 시스템을 확장시켜나가는 방법이 궁금했다. 요즘 채용공고에서도 자주 보이는 "대규모 트래픽 / 대규모 확장 / MSA / 대규모 시스템"과 같은 단어들도 많이 보였기 때문에 궁금증이 높아진 것 같다. 

우선, 단일 서버를 다루기도 했지만, 핵심적으로 유저가 존재하지 않는 환경에서 막상 트래픽이 터지는 상황 자체를 생각할 수 없었다. 서버가 죽는다, 터진다는 것은 무슨 의미인지도 와닿지 않는다.

이런 궁금증을 해결해줄 수 있다며 추천받은 이 책을 통해서 대규모 시스템을 설계하는 방법에 대해서 배워보려고 한다.

## 시스템 확장 (수직적 확장 & 수평적 확장)
시스템을 확장하는 방법에는 2가지가 있다. 수직적 확장과 수평적 확장이다.
### 수직적 확장(Scale Up)
"스케일 업"이라고 부르는 수직적 확장은 서버의 성능 자체를 업그레이드 하는 방법이다. CPU, 메모리, 디스크 등의 하드웨어 성능을 업그레이드하여 서버의 처리 능력을 높이는 것이다. 예를 들어, CPU를 더 빠른 모델로 교체하거나, 메모리를 추가하여 서버의 성능을 향상시킬 수 있다.

그런데, 이 방법에는 치명적인 단점이 있다. 그것은 바로 성능 업그레이드의 한계가 존재한다는 점이다. 즉, 하드웨어의 성능을 무한대로 올릴 수 없다. 무한대로 올릴 수 있다고 가정하더라도 비용이 무지막지하게 들 것이다. 또한, 단지 하나의 서버의 성능만을 높이는 것이기 때문에 단일 서버에서 발생하는 단점들을 그대로 안고 간다. 예를 들면 "장애에 대한 자동복구" 방안이나 다중화 방안을 제시하지 않는다는 점이다. 

즉, 수직적 확장을 하더라도 트래픽이 하나의 서버에 몰리는 것은 여전하다. 
### 수평적 확장(Scale Out)
"스케일 아웃"이라고 부르는 수평적 확장은 여러 대의 서버를 추가하여 시스템의 처리 능력을 향상시키는 방법이다. 즉, 서버를 여러 대로 나누어 트래픽을 분산시키는 것이다. 이 방법은 단일 서버의 성능 한계를 극복할 수 있으며, 장애 발생 시에도 다른 서버가 대체할 수 있어 안정성이 높아진다.

이와 같은 장점들로 인해, 수평적 시스템은 **"대규모 시스템"** 설계에 보다 적절하다고 할 수 있다. 이 수평적 확장을 활용하기 위해서 또 여러 가지 개념들이 필요하다. 트래픽을 분산시켜주는 "샤딩", "로드 밸런서", "데이터베이스 다중화", "데이터 센터" 등이 있다. 하나씩 알아보자.

### 샤딩 
샤딩은 샤드라는 기본 요소로 하여 데이터베이스를 작은 단위로 분할하는 기술이다. 즉, 전체 데이터베이스를 여러 개의 샤드로 나누어 분산 저장하는 방식이다. 이를 통해 데이터베이스의 부하를 분산시키고, 성능을 향상시킬 수 있다. 예를 들어, 사용자 데이터를 사용자 ID에 따라 여러 개의 샤드로 나누어 저장할 수 있다. 이렇게 하면 특정 샤드에 대한 부하가 줄어들고, 전체 시스템의 성능이 향상된다.

샤딩 키를 최대한 데이터를 고르게 분할할 수 있도록 설계하는 것이 가장 중요하다. user_id를 기준으로 샤딩을 한다고 했을 때, 우리가 흔히 아는 연예인이나 인플루언서에 데이터가 몰리는 "유명인사 문제"가 발생할 수 있다. 

### 로드 밸런서
로드 밸런서는 클라이언트의 요청이 들어왔을 때, 트래픽을 여러 대의 서버로 분산시키는 역할을 한다. 즉, 웹 계층에서 어느 한 서버에 트래픽이 몰리게 되는 상황에서 로드 밸런서가 이를 인지하고, 자동으로 트래픽을 분산하여 서버가 다운되는 일을 우아하게 방지할 수 있다.

웹 계층은 이렇게 로드 밸런서를 통해서 수평적 확장을 지원한다. 그렇다면 데이터 계층은 어떻게 수평적 확장을 지원할까? 

### 데이터베이스 다중화 
데이터 계층의 수평적 확장을 위해서 "데이터베이스 다중화"를 지원한다. 서버 사이에 "주 데이터베이스"와 "부 데이터베이스"를 두어 "주 데이터베이스에서는" 쓰기 연산을 지원하고, "부 데이터베이스"에서는 읽기 연산만을 지원하는 방식이다.

즉, insert, delete, update와 같은 쓰기 연산은 주 데이터베이스에서 처리하고, select와 같은 읽기 연산은 부 데이터베이스에서 처리하는 것이다. 일반적으로 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높기 때문에 "부 데이터베이스"를 여러 대 두어 읽기 연산을 분산시킬 수 있다. 

부 데이터베이스가 한 대 뿐인데, 다운이 되어버린 경우에는 어떻게 하면 좋을까? 주 데이터베이스에 읽기 연산까지 추가해서 잠시동안 처리할 수 있도록 하는 방법도 있지만, 이 방법 역시 하나의 데이터베이스에 부하가 몰려 "주 데이터베이스"마저도 다운이 될 수 있다. 즉시 새로운 "부 데이터베이스"서버를 추가하여 장애를 해결할 수 있다. 

주 데이터베이스가 다운되면 어떻게 할까? 이 경우에는 "부 데이터베이스"를 일시적으로 "주 데이터베이스"로 승격시켜서 쓰기 연산을 처리할 수 있도록 한다. 이 경우에는 한 가지 문제가 있다. 바로 "데이터 일관성" 문제이다. 주 데이터베이스의 최신 데이터를 부 데이터베이스가 가지고 있지 않을 때, 이런 상황이 벌어진다. 이와 같은 경우에는 "다중 마스터 기법" 또는 "원형 다중화 기법"을 통해서 대처할 수 있다.

### 캐시
캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 임시로 저장하고 있다가, 동일한 요청이 들어오게 됐을 때 굳이 데이터베이스 단계까지 들어가지 않고, 데이터를 반환하여 성능을 향상시킬 수 있는 저장소이다. 

다음과 같은 상황이라면 캐시 도입을 고려해볼 수 있다.

1. 데이터의 갱신이 자주 일어나지 않는 경우
2. 데이터의 조회가 빈번하게 일어나는 경우 

또한, 캐시를 사용함에 있어 다음과 같은 내용을 고려해야 한다.

1. 캐시는 서버를 재시작하면 사라지는 데이터이기 때문에, 사라져도 문제가 없는 데이터인가?
2. 캐시에 보관되어 있는 데이터들의 만료 시간을 어떻게 설정할 것인가? 
3. 만약 DB에 저장된 데이터를 캐시에 저장해놓았을 때, 일관성을 어떻게 유지할 것인가? 
4. 장애에 어떻게 대처할 것인가?
5. 캐시 메모리는 어떻게 잡을 것인가?
6. 캐시가 가득 찼을 때, 데이터 방출 정책은 어떻게 할 것인가? (LRU, LFU 등)

## 무상태(stateless) 웹 계층
무상태(stateless) 웹 계층은 서버가 클라이언트의 상태를 저장하지 않는 아키텍처를 의미한다. 즉, 각 요청이 독립적으로 처리되며, 이전 요청의 상태나 정보를 기억하지 않는다. 이 방식은 서버의 부하를 줄이고, 확장성을 높이는 데 유리하다.

즉, 상태 정보를 웹 서버로부터 물리적으로 분리하여 단순하고, 안정적이며, 규모 확장에 유리한 구조를 만든다.

## 메시지 큐 (Message Queue)
메시지 큐는 비동기적으로 메시지를 전달하는 시스템이다. 클라이언트와 서버 간의 통신을 비동기적으로 처리하여, 서버의 부하를 줄이고, 확장성을 높이는 데 유리하다. 메시지 큐를 사용하면, 클라이언트가 요청을 보내고, 서버가 응답을 기다리지 않고, 요청을 큐에 저장하고, 서버가 나중에 처리할 수 있다.

이러한 메시지 큐는 메시지의 무손실을 보장한다. 무손실이란 것은 일단 메시지 큐에 보관된 메시지는 소비자가 꺼낼 때까지 안전하게 보관된다는 특성을 뜻한다. 이런 특성 덕분에 메시지 큐는 시스템의 부하를 분산시키고, 장애 발생 시에도 메시지를 안전하게 보관할 수 있다.

## 로그, 모니터링, 자동화 도구
로그, 모니터링, 자동화 도구는 시스템의 상태를 모니터링하고, 운영 도중 발생하는 문제를 해결하는 데 유용하다. 로그는 시스템의 동작을 기록하고, 모니터링 도구는 시스템의 상태를 실시간으로 확인할 수 있다. 자동화 도구는 시스템의 배포, 구성 관리 등을 자동화하여, 운영 효율성을 높이는 데 기여한다. 

Springboot 프레임워크에서는 metric(메트릭)을 수직할 수 있는 Spring Actuator 모듈을 제공한다. 이 모듈을 통해 애플리케이션의 상태를 모니터링하고, 메트릭을 수집할 수 있다. Prometheus라는 저장소에 메트릭 정보를 실시간으로 연동하여 저장할 수 있고, 저장된 내용들을 기반으로 Grafana와 같은 도구를 사용하여 수집한 메트릭을 시각화하고, 시스템의 상태를 모니터링할 수 있다.

## 결론 
지금까지 1장 내용 중 핵심이라고 생각하는 부분들에 대해서 정리해보았다. 대규모 시스템을 설계하기 위해서는 어떤 개념들이 필요한지, 그 개념들이 어떤 용도와 이점을 가지는 지에 대해서 알게 되었다. 배운 개념들을 토대로 내 프로젝트에 적용해보고 싶다는 생각이 들어 그림으로 그려보았다.

![Image](https://github.com/user-attachments/assets/4c0cddbe-d632-403e-88a2-ddb6c62e219d)
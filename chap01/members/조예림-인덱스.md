> 📌 **주의사항**
> 
> 
> 이 글은 『Real MySQL 8.0』 8장을 참고하여, **학습자**의 관점에서 내용을 정리한 문서입니다.
> 
> 잘못된 부분은 언제든 피드백 부탁드립니다!
> 

> 인덱스는 쿼리 성능을 좌우하는 핵심 요소다. 옵티마이저가 아무리 발달해도, 인덱스를 어떻게 설계하느냐는 결국 개발자의 몫이다.
> 

---

## 8.1 디스크 읽기 방식

> 인덱스는 디스크 I/O를 줄이기 위한 도구이고, 그 핵심은 랜덤 I/O를 얼마나 줄이느냐다.
디스크는 랜덤 I/O에 약하므로, 쿼리 성능을 높이려면 인덱스를 잘 설계해 필요한 데이터만 읽도록 해야 한다.
> 

디스크 I/O 성능은 쿼리 성능의 핵심이며, 인덱스는 그 I/O를 어떻게 줄일 것인지에 대한 해법이다.

따라서 인덱스를 이해하기 전, 디스크의 동작 방식을 이해하는 것이 필수다.

### HDD vs SSD

- **HDD**: 내부 플래터가 회전하고, 기계식 헤더가 움직이며 데이터를 읽는다.
    
    → 특히 **랜덤 I/O에서 매우 느림**
    
- **SSD**: 회전 부품 없이 전자식 플래시 메모리를 사용한다.
    
    → **랜덤 I/O에서 HDD보다 훨씬 빠름**
    

> 벤치마크 비교
> 
> 
> HDD: 초당 약 68 트랜잭션
> 
> SSD: 초당 약 436 트랜잭션
> 

※ 참고: SSD도 여전히 순차 I/O가 랜덤 I/O보다 빠르다.

### 랜덤 I/O vs 순차 I/O

- **순차 I/O**: 디스크 헤더를 한 번만 이동해서 연속된 데이터를 읽는다.
    
    → 빠름, 효율적
    
- **랜덤 I/O**: 디스크 헤더를 여러 번 이동해서 여기저기 흩어진 데이터를 읽는다.
    
    → 느림, 비효율적
    

> 예: 3개의 페이지를 저장할 때
> 
> 
> 순차 I/O: 헤더 이동 1번, 시스템 콜 1번
> 
> 랜덤 I/O: 헤더 이동 3번, 시스템 콜 3번
> 

### DB 작업의 현실

대부분의 데이터베이스 작업은 작은 데이터를 자주 읽고 쓰는 방식이다.

→ 결국 대부분의 쿼리는 랜덤 I/O를 자주 발생시킨다.

MySQL은 이런 랜덤 I/O의 부담을 줄이기 위해 다음과 같은 기능들을 제공한다.

- 그룹 커밋
- 바이너리 로그 버퍼
- InnoDB 로그 버퍼

### 인덱스를 언제 쓰고, 언제 안 쓸까?

인덱스를 사용하면 필요한 데이터만 골라서 읽을 수 있지만,

그만큼 **랜덤 I/O가 많이 발생**한다.

반면 테이블 대부분을 읽어야 하는 상황이라면,

**풀 테이블 스캔(순차 I/O)** 이 오히려 더 효율적이다.

→ 그래서 MySQL 옵티마이저는 상황에 따라 인덱스를 무시하고 풀 테이블 스캔을 선택하기도 한다.

→ 이런 전략은 OLTP보다는 데이터 웨어하우스, 통계 분석에서 자주 쓰인다.

### 참고: 순차 I/O도 항상 빠른 건 아니다

- 순차 I/O도 동기화(sync, flush)가 자주 발생하면 느려질 수 있다.
- 이런 경우를 대비해 **RAID 컨트롤러 + 캐시 메모리**를 사용하는 것이 실무에서 중요하다.
    
    → 디스크 하드웨어 자체도 성능 튜닝의 중요한 요소다.
    

---

## 8.2 인덱스란?

> **인덱스는 빠른 조회를 위한 미리 정렬된 안내서다.
읽기를 빠르게 만들수록, 쓰기는 느려진다.
언제, 어떤 인덱스를 만들지 결정하는 건 결국 개발자의 판단이다.**
> 

인덱스는 책의 ‘찾아보기’처럼, **원하는 데이터를 빠르게 찾기 위해 미리 정렬된 키와 주소 정보를 저장해 둔 구조**다.

책 전체 내용을 일일이 훑는 것보다, 찾아보기를 통해 바로 필요한 페이지로 가는 게 빠른 것처럼,

DB에서도 모든 데이터를 다 훑는 것보다, 인덱스를 통해 **필요한 레코드 위치만 바로 찾는 게 훨씬 빠르다.**

### 인덱스와 데이터 파일의 관계

- **데이터 파일**은 ArrayList처럼, **순서대로 쌓인 데이터 모음**
- **인덱스**는 SortedList처럼, **항상 정렬된 상태를 유지하는 데이터 구조**
    
    → 원하는 값을 빠르게 찾을 수 있지만, 정렬 상태를 유지하려면 **삽입/삭제/갱신 비용이 크다**
    

### 인덱스의 본질

- 인덱스는 결국 **읽기 성능을 높이기 위해 쓰기 성능을 희생하는 구조**다.
    
    → 인덱스를 많이 만들수록 `INSERT/UPDATE/DELETE`는 느려지고, `SELECT`는 빨라진다.
    
- 그래서 인덱스를 만들 땐 항상 고민해야 한다:
    
    **“읽기를 얼마나 빠르게 할 것인가?” vs “쓰기를 얼마나 감당할 수 있는가?”**
    
- 단순히 WHERE 조건에 등장한다고 무조건 인덱스를 만드는 건 위험하다.
    
    → 오히려 인덱스가 너무 많으면 **성능이 떨어지고, 저장 공간도 낭비된다.**
    

### 인덱스의 분류 기준

1. **역할에 따라**
    - **Primary Key**: 중복 없이 테이블을 대표하는 키 (NULL 불가)
    - **Secondary Index**: 프라이머리 키 외의 모든 인덱스 (유니크든 아니든 포함)
2. **저장 방식에 따라**
    - **B-Tree 인덱스**: 가장 일반적, 정렬된 값을 기준으로 인덱싱
    - **Hash 인덱스**: 해시값으로 인덱싱, 매우 빠르지만 범위 검색 불가
3. **중복 허용 여부에 따라**
    - **Unique 인덱스**: 중복 불가. 옵티마이저가 “이 쿼리는 결과가 1건일 것”이라고 판단할 수 있음
    - **Non-Unique 인덱스**: 중복 가능. 성능 차이와 처리 방식에 영향 있음
4. **기능에 따라**
    - **전문 검색 인덱스 (Full-text)**
    - **공간 검색 인덱스 (Spatial)**
        
        → 특별한 경우 외엔 일반 B-Tree만으로도 충분하다
        

---

## 8.2 인덱스란?

> **인덱스는 빠른 조회를 위한 정렬된 구조**다.
**읽기를 빠르게 할수록 쓰기는 느려진다.
무턱대고 늘리기보단, 쓰기 부하와 인덱스 효용 사이 균형이 필요하다.**
> 

인덱스는 DB에서 데이터를 빠르게 찾기 위한 구조로, 책의 ‘찾아보기’와 같은 역할을 한다.

데이터(본문)는 정렬 없이 저장되고, 인덱스(찾아보기)는 키-주소 쌍을 **정렬된 상태로 유지**해 빠른 탐색을 가능하게 한다.

프로그래밍 관점에서 보면, 인덱스는 `SortedList`, 데이터는 `ArrayList`와 같다.

`SortedList`는 검색은 빠르지만 삽입·삭제가 느리고, DB 인덱스도 마찬가지로 `SELECT`는 빠르지만 `INSERT/UPDATE/DELETE`는 느려진다.

즉, **인덱스는 읽기 성능을 높이는 대신 쓰기 성능을 희생하는 구조**다.

그래서 모든 칼럼에 인덱스를 걸기보다는, 성능 트레이드오프를 고려해 선택적으로 만들어야 한다.

## 인덱스의 분류

- **역할 기준**
    - *Primary Key*: 테이블을 대표하는 고유 키 (NULL/중복 불가)
    - *Secondary Index*: 나머지 모든 인덱스
- **저장 방식 기준**
    - *B-Tree*: 가장 널리 쓰이며, 정렬된 값 기반
    - *Hash*: 매우 빠르지만 범위 검색 불가 (메모리 DB에 적합)
- **중복 허용 기준**
    - *Unique Index*: 값 중복 불가. 옵티마이저가 1건만 반환된다는 사실을 이용해 최적화
    - *Non-Unique Index*: 중복 허용
- **기능별**
    - *전문 검색 인덱스*, *공간 검색 인덱스* 등 (MySQL에서는 필요할 때만 제한적으로 사용)

---

## 8.3 B-Tree 인덱스

B-Tree는 균형 잡힌 트리 구조로, 정렬된 값을 기반으로 빠른 탐색이 가능한 범용 인덱스 알고리즘이다.

MySQL을 비롯한 대부분의 일반 인덱스는 B-Tree 기반으로 동작한다.

## 8.3.1 구조 및 특징

> B‑Tree 인덱스는
**균형 잡힌 정렬된 트리 구조** 덕분에
**최소한의 탐색 횟수로 원하는 데이터에 접근할 수 있으며**,
MyISAM은 직접 주소를 사용해 한번에 접근하고,
InnoDB는 프라이머리 키를 통해 두 단계 접근을 수행한다.
이 구조 덕분에 **`SELECT` 성능이 크게 향상**되지만,
쓰기(`INSERT`, `UPDATE`, `DELETE`) 시에는 **인덱스 유지 비용**이 발생한다.
> 

B‑Tree 인덱스는 **균형 잡힌 트리 구조**로 구성된다.

- **루트 노드(root)** → **브랜치 노드(branch)** → **리프 노드(leaf)**로 이루어지며,
- **리프 노드**들은 실제 데이터 레코드의 위치(주소)를 가리키는 값을 포함하고 있다.

이 트리 구조 덕분에 인덱스는 항상 **정렬된 상태**로 유지되며, 원하는 데이터를 빠르게 찾을 수 있다.

- 루트에서 시작해 리프까지 내려가며 검색하기 때문에,
- 전체 데이터를 순차적으로 탐색할 필요 없이 **키 값만으로 직접 주소에 접근**할 수 있다.

### 데이터 파일과 인덱스의 관계

![Image](https://github.com/user-attachments/assets/3fbb7155-ac59-496b-bcd7-8d7df080318f)

- **MyISAM**
    - 리프 노드는 실제 데이터의 물리적 주소(RID 또는 오프셋)를 갖는다.
    - 인덱스를 통해 바로 해당 데이터 블록으로 이동할 수 있다.
- **InnoDB**
    - 리프 노드는 **프라이머리 키 값을 주소처럼** 사용한다 (클러스터링 테이블).
    - 따라서 세컨더리 인덱스 검색 시에는,
        1. 세컨더리 인덱스에서 **키 → 프라이머리 키**
        2. 프라이머리 B‑Tree에서 **프라이머리 키 → 실제 레코드**
            
            두 번의 트리 검색이 필요합니다.
            

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

> B-Tree 인덱스는 정렬된 상태를 유지하기 위해
> 
> 
> `INSERT`, `DELETE`, `UPDATE` 시 디스크 I/O 비용이 많이 들며,
> 
> 특히 인덱스가 많을수록 쓰기 성능에 큰 영향을 준다.
> 
> InnoDB는 이를 지연 처리하는 메커니즘(체인지 버퍼)으로 보완한다.
> 

### 키 추가

- 새로운 키는 정렬 순서를 유지하기 위해 적절한 리프 노드를 찾아 삽입된다.
- 노드가 꽉 차면 분할(split) 작업이 발생하고, 이로 인해 상위 노드 구조까지 변경될 수 있다.
- 일반적으로 **테이블에 레코드 1건 추가 비용 = 1**, **인덱스 1개 추가 비용 ≈ 1.5**로 본다.
    
    → 인덱스 3개라면 대략 `1 + (1.5 * 3) = 5.5`배 쓰기 비용
    

### 키 삭제

- 삭제는 리프 노드에서 해당 키에 '삭제 마크'만 하면 된다.
- 이후 재활용되거나 그대로 방치될 수 있다.
- InnoDB는 이 과정도 **지연 처리** 가능하다 (MyISAM은 즉시 처리)

### 키 변경

- B-Tree 인덱스에서 키 값은 위치를 결정하므로, 단순 수정이 불가능하다.
- 기존 키를 삭제 → 새로운 키 삽입 방식으로 처리된다.
- InnoDB는 이 또한 **지연 처리**할 수 있다.

### 키 검색

- 루트 → 브랜치 → 리프 노드를 따라 비교하며 탐색
- `SELECT`, `UPDATE`, `DELETE` 모두 인덱스 검색으로 시작한다
- 인덱스를 사용하려면 키 값이 완전히 일치하거나, **왼쪽부터 순서대로 일치**해야 한다
    
    → 키 중간 이후만 비교하거나, 함수·연산 결과는 인덱스 못 쓴다
    

### 인덱스가 잠금과 관련된 이유

- InnoDB의 레코드 잠금은 반드시 인덱스를 통해 검색한 후에 수행된다.
- 인덱스가 없으면 **더 많은 레코드를 잠그게 되어 성능 저하** 발생
    
    → 심한 경우 테이블 전체 잠금까지 발생할 수 있다
    

→ **인덱스는 검색 성능뿐 아니라, 쓰기 성능·잠금 범위·동시성에도 깊이 관여**한다.

## 8.3.3 B‑Tree 인덱스 성능 영향 요인

> → **인덱스 설계 시에는 키 최소화, 선택도 고려, 읽는 데이터 양을 판단 기준으로 삼아야 함.**
> 
> 
> 
> | 영향 요인 | 성능 영향 |
> | --- | --- |
> | 키 크기 | 작게 → 페이지 밀도↑, I/O ↓ |
> | B‑Tree 깊이 | 얕게 → 탐색 단계 감소 |
> | 선택도 | 높게 → 검색 대상 축소 |
> | 읽는 레코드 비율 | 낮게 → 인덱스 효율 높음 |

### ① **인덱스 키 값의 크기**

- InnoDB는 데이터를 **페이지 단위(기본 16KB)**로 읽고 쓰며, 인덱스도 이 단위로 관리됨.
- 키 값이 클수록 한 페이지에 저장 가능한 키 수가 줄어든다.
    - 예: 키 크기 16바이트 → 페이지당 약 585개 저장
    - 키 크기 32바이트 → 페이지당 약 372개 저장
- 키가 크면 **읽어야 할 페이지 수가 늘어나고**, 인덱스 깊이도 커지므로 **디스크 I/O 증가**.

> ✔ 인덱스 키는 가능하면 작게 설계해야 한다.
> 

### ② **B‑Tree 깊이 (Depth)**

- 트리의 깊이는 **디스크 접근 횟수**와 비례함.
- 같은 깊이(예: 3단계)라면, 키가 크면 저장가능한 키 수가 줄어들고 **검색 단계도 늘어날 수 있음**.
- 일반적으로 인덱스 깊이가 5단계를 넘는 경우는 드뭄.

### ③ **선택도 (Selectivity)**

- 선택도 = 유니크한 키 값 개수
- 유니크 값이 많을수록, **특정 키 검색 시 필터링 대상이 줄어들어 효율↑**
- 예: country에 유니크 값 10개만 있으면, 한 키로 1,000건 검색됨→비효율
- 선택도가 높으면 **검색 효율이 매우 높아짐**.

### ④ **읽어야 하는 레코드 건수**

- 인덱스를 통한 검색은 **테이블 풀 스캔보다 비용이 높음(약 4–5배)**.
- 옵티마이저는 “읽을 레코드 비율이 전체의 약 20–25% 이상”일 때는 **풀 스캔이 더 효율적**이라 간주하고 인덱스를 무시함.
- 즉, 일부 키에 대한 대량의 데이터 조회는 **인덱스 없이 스캔**하는 것이 성능 면에서 유리할 때가 있음.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

MySQL은 인덱스를 다양한 방식으로 활용하며, 그 방식이 성능을 좌우한다.

**대표적인 인덱스 접근 방식 4가지**를 살펴보자.

### ① 인덱스 레인지 스캔 (Index Range Scan)

> 범위 조건 쿼리에 적합한 인덱스 접근 방식
인덱스 → 순차 스캔 → 랜덤 데이터 접근 구조
커버링 인덱스 활용 시 성능 극대화 가능
레코드 비율이 많아지면 테이블 스캔이 오히려 유리
> 

### 정의

- **조건에 해당하는 범위의 인덱스 레코드를 순서대로 읽는 방식**
- 예시: `WHERE first_name BETWEEN 'Ebbe' AND 'Gad'`

### 작동 방식

![Image](https://github.com/user-attachments/assets/83029cfe-e766-429d-b673-aebf2299f080)

![Image](https://github.com/user-attachments/assets/3249be63-4165-4584-a043-0fc8ed33dfa8)

1. **인덱스 탐색 (Seek)**
    - 루트 → 브랜치 → 리프 노드 순으로 탐색
    - 조건에 맞는 **시작 위치**를 찾음
2. **인덱스 스캔 (Scan)**
    - 시작 위치부터 조건에 맞는 인덱스를 정순 또는 역순으로 **차례대로 스캔**
3. **데이터 접근 (Data Access)**
    - 리프 노드에는 **인덱스 키 + 실제 레코드 주소**가 저장됨
    - 해당 주소를 통해 디스크에서 **실제 레코드(데이터)를 랜덤 I/O로 읽음**

### 유의 사항

- 리프 노드에서 **랜덤 디스크 접근이 건수만큼 발생** → 비용 큼
- 읽어야 할 레코드가 전체의 **20~25% 이상**이면 인덱스보다 **테이블 전체 스캔이 효율적**

### 커버링 인덱스 (Covering Index)

- 쿼리에 필요한 모든 컬럼이 인덱스에 있다면 **데이터 파일 접근 생략 가능**
- 랜덤 I/O 없이 리프 노드에서 바로 응답 → 성능 향상

### 상태값 (`SHOW STATUS LIKE 'Handler_%'`)

- `Handler_read_key`: 탐색(Seek) 수행 횟수
- `Handler_read_next`: 정순 스캔 횟수
- `Handler_read_prev`: 역순 스캔 횟수
    
    ※ 실제 데이터 파일 접근 여부는 이 수치로 확인 불가
    

### ② 인덱스 풀 스캔

### 정의

- 인덱스를 **처음부터 끝까지 전부 순차적으로 읽는 방식**
- 예: 인덱스가 `(A, B, C)`인데 쿼리가 `WHERE B = 'x'`처럼 **첫 번째 컬럼이 빠진 조건**인 경우

### 왜 쓰일까?

- 인덱스 조건은 애매하지만 **인덱스 안에 필요한 모든 컬럼이 있을 때**
- 인덱스만 읽어도 되면, **테이블 전체 읽기보다 훨씬 빠름**

### 처리 방식

![Image](https://github.com/user-attachments/assets/b2f8b61f-a586-4260-bbea-593812901340)

1. 인덱스의 리프 노드 **맨 앞 또는 맨 뒤에서 시작**
2. 리프 노드 간 **링크드 리스트** 따라 **전부 순차 스캔**
3. 테이블은 **읽지 않음** (인덱스만 읽음)

### 주의할 점

- **인덱스를 쓰긴 하지만 효율적이진 않음**
- 그래서 일반적으로는 **"인덱스를 잘 활용하지 못했다"**고 평가함
- 인덱스 목적 = 빠른 검색! → 풀 스캔은 그 목적에서 벗어남

### ③ 루스 인덱스 스캔

### 정의

- **"느슨하게" 필요한 인덱스만 골라 읽는 방식**
- 조건에 맞지 않는 인덱스 레코드는 **건너뛰고(skip)**,
- 필요한 부분만 선별적으로 읽는다.
- Oracle의 *Index Skip Scan*과 유사한 기능

### 언제 사용하나?

- `GROUP BY`나 `MIN()`/`MAX()` 같은 **집계 함수 최적화**에 주로 사용
- *인덱스 `(dept_no, emp_no)`*를 예로:
    
    ```sql
    SELECT dept_no, MIN(emp_no)
    FROM dept_emp
    WHERE dept_no BETWEEN 'd002' AND 'd004'
    GROUP BY dept_no;
    ```
    
    → 각 `dept_no` 그룹마다 **최소 `emp_no` 값만 추출**, 불필요한 나머지 `emp_no`는 스킵
    

### 처리 방식

![Image](https://github.com/user-attachments/assets/750f8533-4b27-4c09-9ef4-962f26386278)

1. **리프 노드 상에서 `dept_no` 값이 변경될 때마다 한 번씩만 읽음**
2. **같은 `dept_no` 그룹 내의 다른 `emp_no` 레코드는 건너뜀(skip)**
3. → **전체 범위를 스캔하기는 하지만**, **필요한 레코드만 선별적으로 읽음**

### 장점 & 제약

| 장점 | 제약 |
| --- | --- |
| 인덱스 전체 레코드를 스캔하지 않고 필요한 값만 읽음 | 적용 가능한 쿼리 조건이 **제한적** (주로 집계 최적화) |
| 불필요한 I/O를 줄이고 **검색 성능 향상** | MySQL 5.7 이하에서는 지원이 제한적8.0부터 기능이 점진적으로 확장 |

### ④ 인덱스 스킵 스캔

### 개념

- 기존 인덱스 `(A, B)` 등에서 **선행 컬럼 A 조건 없이도**,
- 옵티마이저가 **A 값을 건너뛰고 B 컬럼만으로 인덱스를 활용**하는 최적화 기법이다.

### 배경

- 전통적 방식은 `(A, B)` 인덱스 사용 시 A 조건이 필수였지만, MySQL 8.0 이상부터는 **`skip_scan` 활성화 시**
    
    `WHERE B = ...`와 같은 일부 상황에서도 이 인덱스를 사용할 수 있다.
    

### 작동 방식 예

```sql
ALTER TABLE employees ADD INDEX ix_gender_birthdate (gender, birth_date);
SELECT gender, birth_date
FROM employees
WHERE birth_date >= '1965-02-01';
```

- **`skip_scan=off`**: `INDEX` 타입 → **풀 인덱스 스캔** (비효율적)
- **`skip_scan=on`**: `range` 타입 + `Using index for skip scan` →
    
    옵티마이저는 `gender` 컬럼의 각 가능한 값(`M`, `F`)을 내부적으로 순회하며
    
    ```sql
    SELECT gender, birth_date WHERE gender='M' AND birth_date>=...;
    SELECT gender, birth_date WHERE gender='F' AND birth_date>=...;
    ```
    
    → 각 그룹별로 `birth_date` 조건만 달리해 범위 탐색 수행 후 결과 합산
    

### 장점

- **인덱스를 재설정하지 않아도**, 선행 컬럼 없이도 범위 조건 인덱스 활용 가능
- 조건 범위가 좁고 인덱스가 커버링할 때 특히 효과적

### 제약

1. **선행 컬럼의 고유(unique) 값 개수가 적어야**
    
    → 아니면 옵티마이저가 탐색 시작점을 계속 잡느라 오히려 비효율적일 수 있음
    
2. **커버링 인덱스여야만 활용 가능**
    
    → 선택된 컬럼 외에 **다른 컬럼이 필요하면**, `skip scan` 사용이 불가능하고 **풀 테이블 스캔** 실행됨
    

### 요약 비교

| 방식 | 사용 조건 | 효과 | 제약 사항 |
| --- | --- | --- | --- |
| **인덱스 레인지 스캔** | 범위 조건, 선행 컬럼 포함 | 순차 스캔 + 랜덤 I/O 필요 가능 | 레코드 비율이 높을 경우 비효율적 |
| **인덱스 풀 스캔** | 모든 인덱스 컬럼 조건, 테이블 컬럼 불필요 | 인덱스만 순차적 스캔 | 인덱스지만 비효율적; 목적과 다를 수 있음 |
| **루스 인덱스 스캔** | 집계 최적화(MIN, MAX, GROUP BY) | 필요한 데이터만 선별적 스캔 | 적용 범위 제한적, 주로 집계에 유효 |
| **인덱스 스킵 스캔** | MySQL 8.0+, 선행 컬럼 조건 없어도 가능 | 인덱스 재작성 없이 사용 가능 | 선행 컬럼 유니크성, 커버링 조건 필요 |

### 8.3.5 다중 컬럼 인덱스 (Multi-Column Index)

### 개념

- **두 개 이상의 컬럼**으로 구성된 인덱스
- 복합 인덱스 / Concatenated Index라고도 함

### 정렬 구조

- **왼쪽 컬럼부터 우선 정렬**
- 두 번째 컬럼은 **첫 번째 컬럼 값이 같은 그룹 내**에서만 정렬 기준
- 컬럼 수가 많아질수록 **계층적으로 정렬**

### 주의사항

- `(A, B, C)` 인덱스는 `A` 없으면 성능 **크게 저하**
- 컬럼 **순서 결정이 매우 중요**

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

> 인덱스는 항상 정렬된 구조지만, 읽는 방향은 쿼리 실행 시점에 결정된다.
> 
> 
> MySQL 옵티마이저는 쿼리 목적에 따라 오름차순/내림차순 중 **효율적인 방향을 선택**한다.
> 

### 인덱스 정렬 vs 읽기 방향

- 인덱스를 생성할 때 `ASC`, `DESC`로 **정렬 순서**를 지정할 수 있다.
- 하지만 실제 쿼리 실행 시점엔 옵티마이저가 판단해 **정순 또는 역순으로 스캔**한다.
- 예: `ORDER BY name DESC` → 인덱스를 **역순 스캔**하면 된다.

```sql
SELECT * FROM employees ORDER BY first_name DESC LIMIT 5;
-- first_name 인덱스를 역순으로 스캔
```

### MySQL 버전별 차이

| 버전 | ASC/DESC 효과 |
| --- | --- |
| MySQL 5.7↓ | 문법만 지원 (ASC로 저장) |
| MySQL 8.0↑ | 실제로 혼합 정렬 인덱스 생성 가능 |

```sql
CREATE INDEX idx_mix ON employees (team_name ASC, user_score DESC);

```

### 정순 vs 역순 스캔 차이

| 항목 | 정순 스캔 (Forward) | 역순 스캔 (Backward) |
| --- | --- | --- |
| 리프 탐색 | 왼쪽 → 오른쪽 순차 탐색 | 오른쪽 → 왼쪽 역순 탐색 |
| 성능 | InnoDB 구조에 최적화 | 성능 불리 (내부 구조상 느림) |
| 이유 | 단방향 링크, 순방향 잠금 구조 | 역방향 탐색 시 부담 증가 |

> InnoDB는 인덱스 페이지 내 레코드를 단방향 링크로 연결하고 있어,
> 
> 
> **정순 탐색은 빠르지만 역순 탐색은 느릴 수밖에 없다.**
> 

### 왜 DESC 인덱스가 필요할까?

**단순 DESC 정렬**

- 역순 스캔으로 충분 (별도 인덱스 불필요)

```sql
SELECT * FROM employees ORDER BY first_name DESC LIMIT 10;

```

**복합 정렬 (ASC + DESC)**

- 역순 스캔만으로는 불가 → **혼합 정렬 인덱스 필요**

```sql
SELECT * FROM employees ORDER BY team_name ASC, user_score DESC;
-- 인덱스: (team_name ASC, user_score DESC) 필요

```

### 실무 팁: 언제 DESC 인덱스를 만들까?

| 상황 | 인덱스 전략 |
| --- | --- |
| 가끔 쓰이는 DESC 쿼리 | 역순 스캔으로 충분 (인덱스 불필요) |
| DESC 쿼리가 자주 실행됨 | 정렬 방향에 맞는 DESC 인덱스 생성 |
| 특정 인덱스 앞/뒤만 집중 탐색됨 | 정렬 방향에 맞게 인덱스 튜닝 필요 |

> 자주 쓰이는 ORDER BY ... DESC LIMIT N 쿼리는
> 
> 
> **항상 인덱스 마지막 페이지만 읽게 되므로 병목이 발생할 수 있다.**
> 
> → 이 경우 **DESC 정렬 인덱스 생성**이 효과적이다.
> 

## 8.3.7 B‑Tree 인덱스의 가용성과 효율성

**왼쪽부터 연속 조건→인덱스 활용 가능**, **범위 이후→체크로만 활용**, **조건 매칭 없으면 전체 스캔**

인덱스는 WHERE, GROUP BY, ORDER BY 절에서 어떻게 활용되는지 정확히 알아야 쿼리 최적화에 유리하다.

조건에 따라 인덱스를 **완전 활용할 수 있는 경우**, **부분만 활용되는 경우**, **아예 쓸 수 없는 경우**를 구분할 수 있어야 한다.

### 8.3.7.1 비교 조건 유형과 인덱스 효율

- **다중 컬럼 인덱스(A, B, C)** 의 경우,
    
    LEFT‑MOST 규칙에 따라 `A`부터 조건이 붙어야 다음 컬럼(B, C)도 인덱스로 효율 읽기가 가능.
    

**사례**

```sql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no>=10144;
```

- **인덱스(A): (dept_no, emp_no)**
    
    → `dept_no='…'`로 시작, `emp_no>=…`로 범위를 좁혀 **모두 인덱스 범위조건**으로 탐색 → 효율적
    
- **인덱스(B): (emp_no, dept_no)**
    
    → `emp_no>=…`만 활용, `dept_no='…'`는 **필터링 조건**으로 뒤에 확인 → 인덱스 범위 조건 하나 + 체크 추가 → 비효율적
    

즉, 인덱스 순서에 따라 **조건절 활용 여부가 달라짐**

- 범위조건까지 연이어서 붙으면 인덱스 **완전 활용**
- 중간에 끊기면 이후는 **체크만 수행** (비용 ↑)

---

### 8.3.7.2 가용성 조건 (Left‑Most Rule)

| 조건 유형 | 인덱스 활용 가능 여부 |
| --- | --- |
| `=` 또는 `IN` | 범위 지점까지 모두 활용 가능 |
| `>`/`<` (비교범위) | 범위 지점 이후는 필터링만 가능 |
| `IS NULL` | 인덱스 활용 가능 |
| `LIKE 'prefix%'` | prefix 있는 경우 가능 |
| `LIKE '%suffix'` | 불가 (왼쪽고정 안됨) |
| 함수/변형된 컬럼 비교 | 불가 |
| NULL 포함 여부 비교 | 인덱스 가능 (MySQL은 저장됨) |
- **IN/LIKE prefix**도 `=`처럼 범위조건으로 작동함.

---

### 8.3.7.3 다중 컬럼 인덱스 활용 규칙

예: `INDEX ix_test (c1, c2, c3, ..., cn)`

- **범위 결정 조건**:
    - `c1 = …`, `c2 = …`, ..., `ci = …/IN/>/</LIKE` (i까지 연속)
        
        → 이 구간은 범위조건으로 인덱스 활용
        
- **그 이후 컬럼**:
    - `ci+1~cn` 조건은 **체크용 필터링**으로만 활용됨

### 예시

```sql
WHERE c1=1 AND c2>10
```

→ `c1` = 범위 시작, `c2>10`은 범위조건

→ `c1`, `c2`까지 인덱스 활용 가능

```sql
WHERE c1=1 AND c2=2 AND c3 IN (10,20) AND c4>100
```

→ `c1~c4` 모두 범위조건

→ `c1~c4` 인덱스 범위조건, 이후 칼럼은 필터링

### 요약

- **Left‑Most 규칙**이 핵심: 인덱스 앞쪽부터 연속 조건이 있어야 효율적으로 사용됨.
- 범위 시작(`>`, `<`, `IN`, `LIKE prefix`) 이후 컬럼은 **필터링**으로만 사용.
- **`=` 조건이 없는 경우** 다중컬럼 인덱스는 전혀 활용 안 됨 → 비효율적
- LIKE 패턴은 **prefix 고정**이어야 인덱스 사용 가능함.

### 실무 가이드

1. **다중컬럼 인덱스 구성 시**, 자주 쓰는 **WHERE/GROUP BY/ORDER BY 조건순**을 기준으로 칼럼 나열
2. **범위 조건의 위치**에 따라 이후 칼럼은 효율 여부가 달라짐 (범위 이후는 여전히 필터용)
3. **LIKE '%…'나 함수 사용 등은 인덱스 활용이 불가능** → 주의해서 쿼리 설계 필요

## 8.5 전문 검색 인덱스 (Full-Text)

### 왜 필요한가?

- B‑Tree 인덱스는 **작은 토큰(단어 일부)**이나 **좌측 일치 검색**에만 유효하며, **빈번한 언어 패턴 기반 검색**에는 적합하지 않다.
- 문서 본문 전체에서 키워드를 찾아야 할 경우에는 **전문 검색용 인덱스**(Full-Text Index)가 요구된다.

### 인덱싱 가능한 최대 키 길이

- B‑Tree 키 크기 제한:
    - InnoDB 기본(DYNAMIC/COMPRESSED): 최대 **3072바이트**
    - MyISAM: 최대 **1000바이트**

---

### 8.5.1 인덱스 알고리즘

### 8.5.1.1 어근(Stem) 기반 인덱싱

- 불필요 단어(*stop words*) 제거 후 주요 단어를 **어근 형태로 분석**(stemming).
- 한국어는 MeCab 등의 형태소 분석기를 사용하며 복잡한 언어 처리 필요.

### 8.5.1.2 n‑gram 기반 인덱싱

- **형태소 분석 없이**, 문자를 n글자 단위로 잘라 인덱스에 저장 (주로 2-gram 사용).
- 예시 문장:
    
    `To be or not to be.` → 토큰: `To, be, or, not, to, be, That, is, the, question`
    
    Bigram: `To`, `be`, `or`, `no`, ..., `on` 등.
    
- 중복된 토큰은 하나로 병합 저장.
- 단순하지만 **인덱스 크기가 커진다**.

---

### 불용어 처리 (Stop Words)

- MySQL이 기본 제공하는 불용어 목록에 해당하면 **인덱스에서 제외됨**.
- 특정 불용어가 검색 방해가 된다면:
    1. **전체 무시**: `my.cnf`에서 `ft_stopword_file=""` 설정 후 서버 재시작.
    2. **InnoDB에서만 무시**: `SET GLOBAL innodb_ft_enable_stopword=OFF;`
    3. **사용자 정의 목록 사용**:
        - `ft_stopword_file='/path/file.txt'` 또는
        - InnoDB 테이블 기반 사용자 정의:
            
            ```sql
            CREATE TABLE my_stopword(value VARCHAR(30)) ENGINE=InnoDB;
            INSERT INTO my_stopword VALUES('MySQL');
            SET GLOBAL innodb_ft_server_stopword_table = 'mydb/my_stopword';
            
            ```
            

---

### 8.5.2 전문 검색 인덱스의 가용성 조건

1. **쿼리**: 반드시 `MATCH(...) AGAINST(...)` 형태여야 활성화됨.
2. **인덱스**: 검색 대상 컬럼에 **FULLTEXT 인덱스**가 반드시 정의되어야 함.
    
    ```sql
    CREATE TABLE tb_test (
      doc_id INT PRIMARY KEY,
      doc_body TEXT,
      FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram
    ) ENGINE=InnoDB;
    
    ```
    
    - 단순 `LIKE '%키워드%'` 쿼리는 Full-Text Index를 이용하지 않고 **풀 테이블 스캔**됨.

## 8.7 Multi-Valued Index (MVI)

### 기존 B-Tree 인덱스와의 차이

- 일반 인덱스는 **레코드 하나에 인덱스 키도 하나 (1:1)**
- MVI는 **레코드 하나에 여러 인덱스 키 (1:N)**
    
    → 배열이나 JSON에 저장된 값들 각각을 **개별 키로 인덱싱**
    

---

## 왜 필요해?

- MySQL이 **JSON 배열**을 지원하지만,
    
    그 배열 내부 값들에 **인덱스를 걸 수 없었음**
    
- MongoDB 등 NoSQL DB는 이미 이런 인덱스 지원
- MySQL 8.0부터 지원됨 → JSON 배열을 효과적으로 인덱싱 가능

---

## 사용 예제

```sql
CREATE TABLE user (
  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  credit_info JSON,
  INDEX mx_creditscores (
    (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY))
  )
);

INSERT INTO user VALUES (
  1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}'
);
```

---

## 검색 방법

일반 WHERE 절로는 안 되고, **특수 함수**를 사용해야 인덱스가 활용됨

- `MEMBER OF()`
- `JSON_CONTAINS()`
- `JSON_OVERLAPS()`

```sql
SELECT * FROM user
WHERE 360 MEMBER OF(credit_info->'$.credit_scores');
```

→ 이 쿼리는 **멀티밸류 인덱스를 활용한 실행 계획이 만들어짐**

---

## 주의 사항

- 현재 MySQL은 **INT, DECIMAL, DATETIME**만 배열로 인덱싱 가능
- `CHAR/VARCHAR` 타입 배열 인덱싱은 아직 미지원
    
    (예: 전화번호 배열 인덱싱은 실패함 → 차후 버전 기대)
    

```sql
-- 실패 예시
CREATE INDEX mx_phoneno (
  (CAST(contacts->'$.phone_no' AS CHAR ARRAY))
);
```

---

## 8.8 클러스터링 인덱스

> 프라이머리 키를 기준으로 레코드를 물리적으로 정렬해 저장하는 방식.
> 
> 
> 검색은 빠르지만, 삽입/변경이 느릴 수 있다.
> 

InnoDB 테이블에서만 사용되는 구조이며, 데이터 레코드는 프라이머리 키 값에 따라 정렬된 채 저장된다.

→ **테이블 = 하나의 인덱스 트리**

---

### 클러스터링 인덱스란?

![Image](https://github.com/user-attachments/assets/aad738e8-1dc4-46bc-9e1e-fa06ebfe107d)

- 프라이머리 키를 기준으로 **레코드 자체가 정렬된 형태로 저장**
- 프라이머리 키 값이 바뀌면 **레코드 위치도 바뀜**
- 하나의 테이블에는 **클러스터링 인덱스는 1개만 존재**
- 일반 인덱스(B-Tree)와 달리 **리프 노드에 전체 컬럼이 저장**

```sql
-- emp_no 값을 바꾸면 레코드 저장 위치도 바뀜
UPDATE tb_test SET emp_no = 100002 WHERE emp_no = 100007;

```

→ emp_no가 바뀌면 해당 레코드는 다른 페이지로 이동됨

---

### 클러스터링 인덱스와 세컨더리 인덱스

> InnoDB는 레코드의 저장 위치가 바뀔 수 있기 때문에,
> 
> 
> **세컨더리 인덱스에 프라이머리 키만 저장해서**
> 
> **레코드 위치가 바뀌어도 세컨더리 인덱스가 변하지 않도록 설계**
> 
- InnoDB의 세컨더리 인덱스는 **레코드 주소가 아닌, 프라이머리 키를 저장**
- 세컨더리 인덱스 → 프라이머리 키 인덱스 → 실제 레코드 로 두 단계 탐색 필요

```sql
-- first_name 인덱스를 통한 검색
SELECT * FROM employees WHERE first_name = 'Aamer';
```

- **MyISAM**: 인덱스가 바로 레코드 주소를 가리킴
- **InnoDB**: 인덱스가 프라이머리 키를 가리키고, 프라이머리 키로 다시 검색

---

### 장점

- 프라이머리 키 범위 검색 성능이 매우 뛰어남
- 세컨더리 인덱스에 프라이머리 키 포함 → **커버링 인덱스로 활용 가능**

### 단점

- 세컨더리 인덱스 크기가 커짐 (프라이머리 키 포함)
- 세컨더리 인덱스를 통한 검색 시 프라이머리 키 탐색 필요
- 프라이머리 키 변경 시 레코드 위치까지 변경 → 느림
- INSERT 시 정렬을 유지해야 하므로 속도가 느림

---

### 사용 시 주의사항

### 1. 프라이머리 키는 최대한 짧게

- 모든 세컨더리 인덱스에 포함되기 때문에 프라이머리 키 크기만큼 **인덱스 전체 크기 증가**

| 프라이머리 키 | 인덱스 크기 증가 |
| --- | --- |
| 10바이트 | 약 47MB |
| 50바이트 | 약 238MB |

### 2. AUTO_INCREMENT보단 업무적으로 대표성 있는 칼럼을 사용

→ 범위 검색 성능 향상

### 3. 프라이머리 키는 명시적으로 설정하자

- 설정하지 않으면 InnoDB가 내부적으로 일련번호 생성 → **사용자는 접근 불가**
- AUTO_INCREMENT라도 명시적으로 설정할 것

### 4. AUTO_INCREMENT를 서러게이트 키로 사용할 수도 있음

- 프라이머리 키가 너무 길고, 세컨더리 인덱스를 많이 쓰는 테이블이라면
- INSERT 위주 테이블이라면 AUTO_INCREMENT 사용이 성능상 유리

---

## 8.9 유니크 인덱스

> 유니크 인덱스는 중복을 허용하지 않는 인덱스이며, 제약 조건의 성격이 강하다.
> 

MySQL에서는 유일성 제약을 걸기 위해 반드시 **인덱스**가 필요하다. 유니크 인덱스를 설정하면, **같은 값이 두 번 이상 저장될 수 없다**는 보장이 생긴다.

단, `NULL`은 값이 없는 상태이므로 **여러 번 저장 가능하다.**

### 프라이머리 키와 유니크 인덱스의 차이

- **프라이머리 키**: `NOT NULL + UNIQUE` 속성 자동 부여.
    
    InnoDB에서는 **클러스터링 인덱스 역할**도 수행.
    
- **유니크 인덱스**: 단순히 중복 금지 제약만 보장.
    
    **클러스터링과는 무관**
    

---

### 8.9.1 유니크 vs 일반 세컨더리 인덱스

### 읽기 성능

- **유니크 인덱스**: 결과가 1건임을 보장할 뿐, 성능이 무조건 빠르진 않음
- **일반 인덱스**: 조건에 맞는 값이 여러 개일 수 있어 CPU가 비교 연산을 추가로 수행함

→ **추가 작업은 디스크 I/O가 아닌 CPU 연산**이므로,
**실제 성능 차이는 거의 없다**

### 쓰기 성능

- 유니크 인덱스는 **중복 값 존재 여부를 체크**해야 하므로,
    - **쓰기 시 더 많은 작업**이 필요함
    - **Change Buffer(변경 버퍼)**를 사용할 수 없음 → 일반 인덱스보다 **느릴 수 있음**
- 특히 InnoDB에서는 유니크 인덱스 쓰기 도중 **데드락 위험**이 상대적으로 높다

---

### 8.9.2 유니크 인덱스 사용 시 주의사항

- 꼭 필요한 경우에만 사용하자
- 유니크 인덱스는 **일반 인덱스와 같은 역할도 수행**함
    - 따라서 같은 컬럼에 `UNIQUE + 일반 INDEX`를 **중복 생성할 필요 없음**

예:

```sql
CREATE TABLE tb_unique (
  id INTEGER NOT NULL,
  nick_name VARCHAR(100),
  PRIMARY KEY (id),
  UNIQUE INDEX ux_nickname (nick_name),
  INDEX ix_nickname (nick_name) -- 이건 불필요
);

```

- 프라이머리 키와 유니크 인덱스를 **같은 컬럼에 중복 설정**하는 것도 피하자

### 요약

- 유일성이 **업무적으로 꼭 필요한 경우** 유니크 인덱스를 사용
- 단순 조회 목적이라면 일반 세컨더리 인덱스로도 충분
- 성능 관점에서 유니크 인덱스는 **쓰기 비용이 높다**는 점을 꼭 고려하자

---

## 8.10 외래키

- **InnoDB에서만 지원**
- 외래 키를 정의하면 참조되는 부모/자식 컬럼에 **자동으로 인덱스 생성**
- 외래 키가 제거되어도 인덱스는 자동 삭제되지 않음

### 특징

1. **부모/자식 간 잠금 대기 발생**
    - 자식 테이블의 외래 키 컬럼(`pid`)을 `INSERT`하거나 `UPDATE` 하면,
        
        부모 테이블에서 해당 키 값의 존재 여부를 **검증하기 위해 읽기 잠금**을 걸고,
        
        **부모 테이블이 쓰기 잠금 상태라면 대기**하게 됨.
        
2. **외래 키와 관련 없는 컬럼은 영향 없음**
    - 자식 테이블의 다른 컬럼(`fd`)을 수정할 때는 **잠금 대기가 발생하지 않음**

---

**요약**

- 외래 키가 걸린 컬럼을 수정하면 **부모 테이블 잠금으로 인한 지연**이 있을 수 있음
- 설계 시 **참조 무결성 유지 vs 동시성 이슈**를 반드시 고려해야 함
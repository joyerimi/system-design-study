## 1. 문서 개요

- **이 문서의 목표**
    
    수평 확장을 위해 데이터를 안정적으로 분산하는 방식 중 하나인 **Consistent Hashing**의 개념과 필요성, 구현 방법, 한계 및 보완 전략을 학습합니다.
    
- **독자가 얻게 될 것**
    - 분산 시스템에서 데이터 분산의 어려움 이해
    - 일반 해싱 방식의 한계와 캐시 미스 문제
    - Consistent Hashing의 원리 및 장점
    - 가상 노드, 핫키/핫스팟 문제 등 실전에서 고려할 요소

---

## 2. 기존 해싱 방식과 한계

### 2.1 수평 확장을 위한 데이터 분산

수평적 확장을 통해 시스템 처리량을 늘리기 위해서는 데이터를 여러 서버에 균등하게 나눠야 합니다. 가장 기본적인 분산 방식은 해시 함수를 활용한 분할입니다.

```
serverIndex = hash(key) % N
```

- `key`를 해시한 후 서버 개수 `N`으로 나누어 특정 서버에 매핑합니다.
- 구조가 단순하고 성능이 빠르며, 서버 수가 고정되어 있다면 매우 효율적입니다.

![image.png](https://github.com/user-attachments/assets/5e7d7b77-181e-495e-ae02-166d35ad9834)

![image.png](https://github.com/user-attachments/assets/b0d7f172-66e3-42ef-b55e-48282ca7cb8d)

### 2.2 문제점: 서버 수 변화에 따른 재해싱 문제

서버가 **추가되거나 제거**되면 `N` 값이 바뀌기 때문에 대부분의 키가 다른 서버로 이동하게 됩니다. 이로 인해 다음과 같은 문제가 발생합니다.

- **대규모 캐시 미스** → 데이터 불일치, 응답 지연
- **시스템 성능 급락**
- **유지보수가 어려움**

![image.png](https://github.com/user-attachments/assets/aa1f4a94-16fe-4b60-985d-87fefb9a2201)

![image.png](https://github.com/user-attachments/assets/7a8f725a-4c04-4b10-a2b0-d61b47f91711)

---

## 3. Consistent Hashing의 등장과 개념

### 3.1 문제 해결을 위한 접근: 키 이동 최소화

기존의 분산 방식인 `hash(key) % N`에서는 서버 수 `N`이 바뀌면 대부분의 키가 다른 서버로 재배치됩니다. 이는 대규모 **캐시 미스**, **성능 저하**, **서비스 불안정**을 유발합니다.

**Consistent Hashing**은 이러한 문제를 해결하기 위해 고안된 알고리즘으로, 서버 수 변경 시에도 전체 키의 일부만 재배치되도록 설계되었습니다.

- **정의**: 해시 테이블 크기가 조정될 때, 전체 키 `K` 중 평균적으로 `K/N`개의 키만 재배치하는 해시 기법
- 서버 추가/제거 시 **이동하는 키의 수를 최소화**하여 서비스의 안정성을 높입니다

> 💬 내 생각
> 
> 
> Consistent Hashing이란 이름을 처음 들었을 땐 “항상 같은 결과를 내는 해시”라는 느낌인가?라고 생각했다. 실제로는 서버가 추가되거나 제거돼도 전체 시스템이 안정적으로 유지된다는 말인 것 같다. 즉, 수평적 확장을 안정적으로 지원한다는 말 !
> 

### 3.2 해시 공간과 해시 링의 개념

Consistent Hashing은 기존 해시 분할 방식과 다르게, **해시 공간을 원형(Ring)으로 구성**하여 키와 서버를 배치합니다.

### 개념 설명

- **해시 공간**
    
    해시 함수의 출력값 범위입니다. 예를 들어 SHA-1이라면 `0 ~ 2^160 - 1` 범위입니다.
    
    ![image.png](https://github.com/user-attachments/assets/e40f298f-ff8f-44b5-8edb-e01355979f5d)
    
- **해시 링(Hash Ring)**
    
    해시 공간을 원형으로 연결한 구조입니다. 이 링 위에 서버와 키를 위치시킵니다.
    
    ![image.png](https://github.com/user-attachments/assets/6c40c596-051c-4998-bd3c-5f2478bf1328)
    
- **서버 배치**
    
    각 서버는 이름이나 IP를 해시하여 링 위에 배치됩니다. 일반적으로 **정적인 서버 이름**을 사용하는 것이 안정적입니다.
    
    ![image.png](https://github.com/user-attachments/assets/23f72d1f-1801-4a26-a999-fd93b2305ffa)
    
- **키 배치**
    
    각 데이터 키도 동일한 해시 함수로 변환되어 링 위에 배치됩니다.
    
    → **키는 시계 방향으로 가장 가까운 서버에 할당됩니다.**
    
    ![image.png](https://github.com/user-attachments/assets/ca6da916-e431-4824-8407-e3d91decbe29)
    

### 3.3 기존 해싱 방식과 비교

| 항목 | 전통 해시 (`hash(key) % N`) | Consistent Hashing |
| --- | --- | --- |
| 키 → 서버 매핑 방식 | `% N` 연산 | 시계방향 탐색 |
| 서버 수 변경 시 영향 | 거의 모든 키 재배치 | 평균 `K/N`만 이동 |
| 분산 균형도 | 좋음 (단, 서버 고정 시) | 가상 노드 필요 시 보완 가능 |

### 3.4 서버 동작 (조회/추가/제거)

### 서버 조회

- 키에 해시 함수를 적용하여 해시 링 상의 위치를 찾습니다.
- 링을 **시계 방향으로 탐색**하여 가장 먼저 만나는 서버를 찾습니다.
- 그 서버가 해당 키를 담당하게 됩니다.

![image.png](https://github.com/user-attachments/assets/487660f3-c629-42c3-b873-e0a9652fcfc2)

> 예: key1의 위치에서 시계 방향으로 탐색한 결과, 가장 먼저 만나는 서버가 서버 1이라면, key1은 서버 1에 저장됩니다.
> 

### 서버 추가

- 새로운 서버를 해시 링에 삽입합니다.
- 그 위치 **이전 키들의 일부**만 새 서버로 재배치됩니다.

![image.png](https://github.com/user-attachments/assets/f7b513bd-94a8-48ba-885b-d219b06c00c9)

> 예: 서버 4가 추가되면 key0만 서버 4로 이동, 나머지는 그대로 유지됨
> 

### 서버 제거

- 해당 서버의 키는 **다음 서버**로 이동합니다.
- 전체 키 중 소수만 이동 → 대규모 캐시 미스 없음

![image.png](https://github.com/user-attachments/assets/b39a0c9a-6479-4985-807e-280102bd7c4e)

> 예: 서버 1 제거 시, 서버 2가 key1을 대신 받게 됨
> 

---

## 4. Consistent Hashing의 한계와 가상 노드로의 보완

### 4.1 문제점

Consistent Hashing은 서버와 키를 **균등 분포 해시 함수**를 이용해 링에 배치하고, 키의 위치에서 시계 방향으로 탐색해 처음 만나는 서버에 저장하는 방식입니다. 하지만 이 기본 방식은 다음과 같은 두 가지 문제를 가집니다.

### ① 파티션 불균형 문제

- 해시 링에서 **서버 간 간격(파티션)**이 불균형하게 될 수 있음
- 특히 서버 수가 적거나, 서버 해시 값이 몰릴 경우
- 서버를 삭제하면 인접한 서버가 **불균형하게 많은 키**를 떠맡게 됨
    
    → 부하 집중
    

> 예: 서버 1이 삭제되면, 서버 2의 파티션이 두 배 가까이 커짐 → 서버 2에 부하 집중됨
> 

![image.png](https://github.com/user-attachments/assets/cd505e72-0993-4306-9ea9-f3f93ac845e8)

### ② 키 쏠림 문제

- 해시 함수는 통계적으로 균등 분포하더라도, **샘플 수가 적으면 편차가 큼**
- 일부 서버에만 데이터가 몰리고, 나머지는 거의 무부하
- 특히 서버 수가 적거나, 특정 해시 값이 우연히 몰릴 경우 심화됨

![image.png](https://github.com/user-attachments/assets/4c8e58ce-b60a-4e8a-8a23-693a397a97de)

> 예: 서버 1과 3은 아무 데이터도 갖지 않지만, **대부분의 키가 서버 2에 집중됨**
> 

> 📌 균등 분포 해시 함수란?
> 
> 
> SHA-1, MurmurHash, MD5 등과 같이 입력값을 해시 공간 전체에 고르게 퍼뜨리는 함수.
> 
> 하지만 결과의 고름은 **통계적 성질**이므로, **샘플이 적으면 불균형이 생길 수 있음**.
> 

### 4.2 해결책: 가상 노드(Virtual Node)

**가상 노드**는 하나의 실제 서버를 여러 개의 논리 노드로 나누어 **해시 링에 여러 위치에 중복 배치**하는 방식입니다.

- 예: 서버 A → `A_0`, `A_1`, `A_2` 등의 가상 노드로 등록
- 각 가상 노드는 해시 링의 다른 위치에 퍼지도록 설정

### 동작 방식

- 키는 **해시 결과 위치에서 시계 방향으로 처음 만나는 가상 노드**에 할당됨
- 해당 가상 노드가 가리키는 **실제 서버**가 데이터를 저장
- 예: `k0` → `s1_1` → 실제 서버 1

![image.png](https://github.com/user-attachments/assets/93fab911-6af0-4a05-bf7e-d69e85db9154)

### 장점

- 가상 노드 수가 많을수록 키 분포가 고르게 퍼짐 (표준 편차 감소)
- 핫스팟 문제 완화 → **부하 분산**, **서버 과부하 방지**
- 서버 수가 적더라도 **분산 품질 유지**
- 장애 발생 시 영향이 국소화됨

| 가상 노드 수 | 평균 표준 편차 |
| --- | --- |
| 100개 | 약 10% |
| 200개 | 약 5% |

### 단점 및 고려사항

- 가상 노드 수 증가 → **링 관리 비용 증가**
- 각 노드마다 가상 노드 수를 적절히 조정해야 함 (Trade-off 필요)

### 서버 추가/삭제 시 키 재배치

- 가상 노드가 있어도 **재배치 원칙은 동일**
- 다만 단위가 "서버"가 아닌 **"가상 노드" 단위로 더 정밀하게 나뉨**

---

## 5. 실전 적용 사례

- 분산 캐시 (예: Redis Cluster)
    - 다수의 캐시 노드에 데이터를 분산 저장
- 분산 데이터베이스
    - 데이터를 파티셔닝(샤딩)해서 여러 DB 노드에 저장
    - 클러스터 확장 시 안정 해시로 파티션 이동 최소화
- CDN (예: Cloudflare)
    - 전 세계 엣지 서버에 콘텐츠를 균등하게 분산
    - 서버 장애나 추가 시에도 기존 콘텐츠 무효화 최소화
- 로드 밸런서 (예: NGINX)
    - 클라이언트 요청을 백엔드 서버로 분산할 때, 같은 키(사용자 세션 등)가 **항상 같은 서버**로 가도록 라우팅
    - 서버 추가/삭제 시에도 최소한의 사용자만 영향 받음
- P2P 네트워크

---

## 6. Consistent Hashing의 실전 보완 전략

### 6.1 핫키(Hot Key) 문제 대응

**핫키**란 자주 요청되는 특정 키가 하나의 서버에 과도하게 집중되는 문제입니다.

예: `"justin_bieber_profile"` → 서버 A만 계속 부하

**해결 방법**

- 동일 키를 **여러 서버에 복제 저장** → 읽기 부하 분산
- **다중 해시 함수**를 활용 → 여러 서버 후보를 만들어 트래픽 분산
- 로드밸런서가 **가장 부하가 적은 서버**를 선택

### 6.2 핫스팟(Hotspot) 문제 대응

서버 간 키 분포는 균등하지만, **일부 노드에만 요청이 집중**될 수 있음

**해결 방법**

- **가상 노드** 수 증가
- **샤딩**과 **트래픽 기반 분산 라우팅**
- 실시간 모니터링을 통한 **동적 분산 조절**

### 6.3 보완 알고리즘: Rendezvous Hashing

**Consistent Hashing보다 더 간단한 방식**

### 작동 원리

1. 각 키에 대해 모든 서버에 대해 점수 계산
    
    → `score = hash(key + server_id)`
    
2. 점수가 가장 높은 서버에 키를 할당

```
예시:
key = "apple"
"apple + 서버1" → 500
"apple + 서버2" → 900  ← 선택됨
"apple + 서버3" → 300
```

### 장점

- 해시 링 불필요
- 구현 간단
- 서버 추가/제거 시에도 `1/N`만 재배치됨

### 비교

| 항목 | Consistent Hashing | Rendezvous Hashing |
| --- | --- | --- |
| 구조 | 해시 링 | 점수 기반 우선순위 |
| 구현 복잡도 | 비교적 복잡 | 간단함 |
| 키 이동량 | 평균 1/N | 평균 1/N |
| 가상 노드 필요 여부 | 필요함 | 거의 불필요 |

---

## 7. 결론 및 요약

- **Consistent Hashing**은 서버 추가/제거 시에도 **키 재배치량을 최소화**하는 강력한 데이터 분산 전략입니다.
- **기본 해시 분산 방식의 한계**(캐시 미스, 성능 저하)를 해결하는 데 효과적입니다.
- **가상 노드**를 통해 키 분포 불균형 문제도 해결 가능하지만, 구성 복잡성과 자원 소비를 고려해야 합니다.
- **핫키/핫스팟 문제**는 가상 노드 외에도 키 복제, 다중 해시, 로드밸런싱 등을 통해 보완합니다.
- **Rendezvous Hashing**은 간단한 대안으로, 특정 상황에서 유용하게 사용될 수 있습니다.

---

## 8. 회고

이번 장을 읽으면서 수평적 확장을 할 때 해싱이 어떤 식으로 활용되는지, 그리고 Redis나 Cassandra 같은 분산 시스템들이 내부적으로 어떻게 구성되어 있는지 감을 잡을 수 있어서 좋았다.

특히 단순히 해시 함수를 쓰는 게 아니라, 서버가 늘어나거나 줄어들 때 안정적으로 키를 재배치하는 구조가 있다는 걸 알게 되니, 장애나 성능 이슈가 생겼을 때도 좀 더 구조적으로 이해하고 대응할 수 있을 것 같다는 생각이 들었다.
# 들어가며

5장에서는 시스템 설계를 할 때에 서버가 사라지거나 생겨났을 때, 기존의 키들을 어떻게 재배치하고, 어떤 방식으로 효율적으로 재배치할 수 있는가를 다루는 챕터이다. 이런 문제가
있을 것이라고는 생각해 본 적이 없는 것 같다. 항상 단일 서버에서만 프로젝트를 진행했기 때문에 서버가 생겨나고, 사라지는 상황에 대해서 고민해본 적이 없었다. 하지만, 이 문제를
해결하기 위해서는 어떻게 해야 할지에 대해서 공부해보자.

## 해시 키 재배치(rehash) 문제

해시 키 재배치 문제는 수평적 서버 확장과 깊은 관련이 있다. 수평적 서버 확장은 "Scale Out"이라고도 하며, 서버의 스펙을 높이는 것이 아닌 개수를 늘리는 전략이다.
그러면 이런 수평적 규모 확장 전략을 가지는 서버에서 다음과 같은 일이 있다고 하자.

### 문제 발생 상황

N개의 서버가 있고, 각 키들은 `hash % N` 결괏값 즉, 키 해시값을 서버의 개수로 나눈 나머지를 활용하는 해시함수를 사용하여 각 서버에 분산 저장한다

- 예를 들어, 서버가 3개이고, 키가 5개라고 가정했을 때, 키는 다음과 같이 분산 저장된다.
    - 키1: hash(키1) % 3 = 0 (서버1)
    - 키2: hash(키2) % 3 = 1 (서버2)
    - 키3: hash(키3) % 3 = 2 (서버3)
    - 키4: hash(키4) % 3 = 0 (서버1)
    - 키5: hash(키5) % 3 = 1 (서버2)

이때, 서버의 개수가 1개 줄어들거나, 1개 증가한다고 가정해보면 사라진 서버에 저장된 키는 어떻게 재배치 할 것이며, 새롭게 생겨난 서버의 키는 어떻게 재배치 할 것인가에 대한
문제가 발생한다.

![Image](https://github.com/user-attachments/assets/93679ca8-e8fb-463b-9d4d-4f528ee0354b)

만약 서버가 1개 줄었을 때, 사라진 서버의 키를 무작위로 다른 서버에 재배치 하게 된다면 캐시 서버를 사용하는 상황에서 엄청난 캐시 미스가 발생할 것이다. 이런
문제점을 해결하기 위한 방법이 바로 `안정 해시`이다.

## 안정 해시

안정 해시는 `0 ~ 2^160 - 1` 즉, 160비트의 해시값을 갖는 키를 `0 ~ 2^160 - 1` 범위의 원형 공간에 매핑하는 방식이다. 이 방식을 활용하면 해시 테이블
크기가 조정될 때 평균적으로 오직 `k/n`개의 키만 재배치된다. (k: 키의 개수 / n: 슬롯의 개수)

### 해시 서버

원형으로 만든 해시 테이블에서 해시 함수 f가 존재한다고 가정했을 때, 해시 함수를 사용하면 서버 IP나 이름을 링 위의 어떤 위치에 대응시킬 수 있다.

### 해시 키

여기서 해시 알고리즘은 위에서 설명한 `모듈러 연산` 방식이 아니다.

### 서버 조회

여기서 신기한 점은 해시 키를 저장될 때, 현재 해시 키가 존재하는 시계 방향으로 가장 가까운 서버를 찾아 저장된다. 조회될 때에도 마찬가지 방식을 따른다.

### 서버 추가 및 제거

![Image](https://github.com/user-attachments/assets/a19f11b1-b14e-44bc-a314-9e650d2f9d36)

이런 서버 저장 및 조회 방식이라면 서버가 추가될 때, 일부의 해시 키들만 재배치를 수행하면 되기 때문에 효율적이다. 마찬가지로 서버가 제거되더라도 일부의 해시 키들만 재분배를
시켜주면 된다.

## 기본 구현법

안정 해시 알고리즘은 MIT에서 처음 제안된 알고리즘이다. 기본 절차는 다음과 같다.

1. 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치한다.
2. 특정 해시 키에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버에 키가 저장된다.

이 절차에는 2가지 문제가 있다.

### 파티션 크기 균등 불가능

![Image](https://github.com/user-attachments/assets/c18abf1f-4454-4df6-8f07-69941b5ffc0c)

서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는 게 불가능하다. 여기서 파티션의 크기는 어느 한 서버의 반시계 방향으로 가장 처음 만나는 서버까지의
공간을 의미한다.

### 키의 균등 분포 달성의 어려움

![Image](https://github.com/user-attachments/assets/6d030995-3b2e-4fea-9a51-60b4cde34147)

키의 균등 분포 또한 달성하기 어려운 영역이다.

## 가상 노드

파티션 크기 균등 불가능 문제와 키의 균등 분포 달성의 어려움을 해결할 수 있는 방법으로 `가상 노드` 또는 `복제(Replica)`기법을 활용할 수 있다. 가상노드는 실제 노드
또는 서버를 가리키는 노드이다. 즉, 링 위에 하나의 서버는 여러 개의 가상 노드를 가질 수 있다.

![Image](https://github.com/user-attachments/assets/f59cc1d4-7a58-42a4-898d-50ca8f597b22)

가상 노드의 개수를 늘리면 당연하게도 키의 분포는 점점 균등해진다. 늘린 만큼 가상 노드 데이터를 저장할 공간이 더 필요하다는 `trade-off`가 존재한다. 이 부분은 각 분산
서버의 상황에 맞게 타협적 결정이 필요하다.

### 재배치할 키 결정

재배치할 키는 당연하게도 어느 한 서버에서 `반시계 방향`으로 가장 처음 만나는 서버까지의 범위의 해시 키들이다.

## 요약

1. 서버의 수평적 확장을 전략으로 가지는 시스템에서는 키를 각 서버에 분산 저장해야하는데 해시 함수를 사용한다.
2. 해시 함수를 사용하게 되면 서버가 추가되거나 제거될 때, 키의 재배치가 필요하다. 무작위로 재배치할 경우 캐시 미스가 대규모로 발생할 수 있다.
3. 따라서, 대규모 캐시 미스를 방지하기 위해 `안정 해시` 알고리즘을 사용한다.
4. 안정 해시도 파티션 크기 균등 불가능 문제와 키의 균등 분포 달성의 어려움이 존재한다.
5. 이 문제를 해결하기 위해 `가상 노드` 또는 `복제(Replica)` 기법을 사용한다. 가상 노드는 실제 노드 또는 서버를 가리키는 노드이다.
6. 가상 노드의 개수를 늘리면 키의 분포는 점점 균등해지지만, 늘린 만큼 가상 노드 데이터를 저장할 공간이 더 필요하다는 `trade-off`가 존재한다.
7. 재배치할 키는 어느 한 서버에서 반시계 방향으로 가장 처음 만나는 서버까지의 범위의 해시 키들이다.
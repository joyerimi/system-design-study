# 5장 : 안정 해시 설계

### 해시 ?
임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수를 해시 함수라고 합니다.
해시 함수에 의해 얻어지는 값을 해시 값, 해시 코드, 해시 체크섬 혹은 간단하게 해시라고도 합니다.

해시 함수의 특징은 크게 3가지가 있습니다.
1. 단방향성 (One-way Property):
      해시 함수는 입력값을 해시하여 출력값을 생성하지만, 출력값으로부터 원래 입력값을 역추론하는 것이 매우 어렵거나 불가능해야 합니다.
2. 충돌 저항성 (Collision Resistance):
   서로 다른 두 입력값이 동일한 해시값을 갖는 경우를 충돌이라고 합니다.
   좋은 해시 함수는 충돌이 발생할 가능성을 최소화하도록 설계되어야 합니다.
    오래된 해시 함수의 경우 충돌 가능성이 존재하므로 충돌가능성이 희박한 해시 함수를 사용해야 합니다. 
3. 동일 입력, 동일 출력 (Deterministic):
   동일한 입력값에 대해서는 항상 동일한 해시값을 반환해야 합니다. 

해시의 경우 수평적으로 규모를 확장한 서버에 고른 분포를 할 수 있게 도와줍니다.

## 해시 키 재배치 문제
N개의 캐시 서버가 있을 때 해시 함수를 사용하면 부하를 균등하게 나눌 수 있습니다.
만약 일부 서버에 장애가 발생해 중단되는 경우, 작동 가능한 서버 풀 내에서 해시 값을 재배치해주어야 합니다.
하지만 해시 함수의 값에 가용한 서버 수 N을 사용하는 경우(책의 경우 모듈러 연산에 사용) N이 변하며 캐시 미스가 발생할 수 있습니다.

![Image](https://github.com/user-attachments/assets/e423777a-3eca-4e14-809b-be49891c77f7)

기존에는 4대의 캐시 서버를 사용해서 값을 저장하였지만, server1이 중단되면 % 3 연산을 하게 되고, 이는 상당 수의 캐시 미스가 발생하게 됩니다.
이러한 문제를 해결하기 위해 안정 해시를 사용합니다.

## 안정 해시
해시 테이블 크기가 조정될 때 평균적으로 k/n개의 키만 재배치하는 해시 기술입니다.
k는 키의 개수, n은 슬롯의 개수입니다.

### 해시 공간과 해시 링
SHA-1의 출력 값 범위를 원의 형태로 표현하면 해시 링이 만들어 집니다.

![Image](https://github.com/user-attachments/assets/42634d82-9408-49fa-b06b-2e9477ee75d3)

이 공간의 임의의 위치에 해시 서버를 배치하고 해시 키도 배치할 수 있습니다.
각각의 해시 키는 시계 방향으로 링을 탐색하며 가장 가까운 해시 서버에 할당됩니다.

![Image](https://github.com/user-attachments/assets/f72b2aa1-0aee-45c4-b596-3f3f49c5a4fc)

링 데이터 구조로 구현하면, 모든 키를 재배치할 필요없이 서버가 생성되고 삭제되는 구간에 있는 키만 재배치하면 됩니다.

### 기본 구현법의 두 가지 문제
위와 같은 방법은 두 가지 문제가 있습니다.
1. 서버가 추가되거나 삭제될 때 파티션(서버와 서버 사이의 공간)의 크기를 균등하게 유지하는 것이 불가능하다.
2. 키의 균등 분포가 어렵다.(1번 문제의 연장선??)

![Image](https://github.com/user-attachments/assets/1f36d00c-1833-4275-a7c7-cadae7fc96ad)

### 가상 노드
기본 구현법이 가지는 한계를 극복하기 위해 도입된 기법입니다.
가상 노드는 실제 노드 또는 서버를 가리키는 노드로, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있습니다.
가상 노드를 사용하게 되면 서버는 여러 개의 파티션을 관리해야 합니다.

![Image](https://github.com/user-attachments/assets/4ba4f2bc-7765-4284-9e75-47e83ac6ed78)

가상 노드의 개수를 늘릴수록 키의 분포는 점점 더 균등해집니다. 표준 편차가 작아져서 데이터가 고르게 분포되기 때문입니다.
가상 노드를 늘릴수록 표준 편차의 값은 떨어지지만, 노드 데이터를 저장할 공간이 많이 필요해지므로 trade-off가 발생합니다.
서버가 추가되거나 삭제될 때는 기본 구현 방법처럼 시계 방향으로 링을 탐색해 할당될 서버의 가상 노드를 찾습니다.

### 마치며
안정 해시의 이점은 다음과 같습니다.
1. 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
2. 데이터가 보다 균등하게 분포되므로 수평적 규모 확장성을 달성하기 쉽다.
3. 핫스팟 키 문제를 줄인다.

# 나의 질문  : 다른 안정 해시는 없나?
## Jump consistent hash
구글에서 만들었습니다. 키를 분배할 때 특별한 알고리즘을 사용하여
1. 메모리 사용이 거의 없고
2. 빠르고
3. 데이터와 부하를 균등하게 분배하는
것이 가능합니다.

### 동작 원리
키와 노드 수를 입력받아 반복적으로 점프할 위치를 찾습니다.
확률과 위치는 난수에 의존합니다.
노드 수가 증가하더라도, 재배치해야 하는 키는 1 / (버킷 수)개만 재배치하면 되고, 대부분의 데이터는 기존 노드를 유지합니다.

```
int32_t JumpConsistentHash(uint64_t key, int32_t num_buckets) {
    int64_t b = -1, j = 0;
    while (j < num_buckets) {
        b = j;
        key = key * 2862933555777941757ULL + 1;
        j = (b + 1) * (double(1LL << 31) / double((key >> 33) + 1));
    }
    return b;
}
```

### 성능 및 장점
노드 수가 커져도 로그 시간 복잡도를 보입니다.

### 한계 및 제약 사항
1. 알고리즘 특성 상 노드 번호가 연속된 정수여야 합니다. 임의의 서버 ID나 비연속적인 노드 번호는 지원하지 않습니다.
    따라서 분산 웹 캐시 같이 서버가 임의로 추가/삭제되는 환경에서는 적합하지 않고, 데이터 저장(sharding) 시스템에 어울립니다.
2. 노드 추가만 고려하고 임의의 버킷 제거가 불가능합니다. 알고리즘 자체가 제거되는 상황은 고려하지 않습니다.
    데이터 저장 시스템에서는 복제나 복구로 삭제되는 경우를 대응할 수 있으며, 실제 데이터가 있는 노드가 갑자기 없어지는 경우는 드물어 제약을 감수합니다.
3. 키가 64비트 정수여야 하거나 64비트 해시가 필요합니다.

### 나의 정리
책에서 설명한 캐시 서버에 적용하기에는 어렵고, DB sharding 과정에 적용하면 좋을 것 같습니다.


### 참고문헌
[해시 함수](https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98)

[해시 충돌 해결법](https://www.youtube.com/watch?v=Rpbj6jMYKag)

[Jump consistent hash](https://chongkong.github.io/jump-consistent-hash)

[Erlang](https://en.wikipedia.org/wiki/Erlang_(programming_language))

[A Fast, Minimal Memory, Consistent Hash Algorithm](https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf)